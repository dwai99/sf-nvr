<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SF-NVR - Playback</title>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">

    <!-- UI Utilities -->
    <script src="/static/notifications.js"></script>
    <script src="/static/ui-utils.js"></script>
    <script src="/static/timeline-selector.js?v=4"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #4a9eff;
            font-size: 1.5em;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .stats {
            display: flex;
            gap: 20px;
        }

        .stat {
            background: #333;
            padding: 10px 20px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-label {
            color: #888;
            font-size: 0.9em;
        }

        .stat-value {
            color: #4a9eff;
            font-size: 1.5em;
            font-weight: bold;
        }

        .btn {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .btn:hover { background: #3a8eef; }

        .btn-success {
            background: #4aff4a;
            color: #000;
        }

        .btn-success:hover { background: #3aef3a; }

        .controls-panel {
            background: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 2px solid #333;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.85em;
            color: #888;
        }

        .control-group input,
        .control-group select {
            background: #333;
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .video-grid {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 10px;
            padding: 10px;
            overflow-y: auto;
        }

        .video-container {
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .video-header {
            background: #333;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4a9eff;
        }

        .video-name {
            font-weight: bold;
            font-size: 1.1em;
        }

        .video-player {
            flex: 1;
            background: #000;
            position: relative;
            min-height: 300px;
            overflow: hidden;
            cursor: default;
        }

        .video-timestamp-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #4a9eff;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            font-weight: bold;
            z-index: 10;
            pointer-events: none;
        }

        /* Motion event indicator overlay */
        .motion-indicator-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 87, 34, 0.9);
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
            z-index: 15;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .motion-indicator-overlay.active {
            opacity: 1;
        }

        .motion-indicator-overlay.ai-person {
            background: rgba(156, 39, 176, 0.9);
        }

        .motion-indicator-overlay.ai-vehicle {
            background: rgba(33, 150, 243, 0.9);
        }

        .motion-indicator-overlay .motion-icon {
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            animation: motion-pulse 0.5s ease-in-out infinite;
        }

        @keyframes motion-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* Fullscreen mode styling for video player */
        .video-player:fullscreen {
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-player:fullscreen video {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        .video-player:fullscreen .motion-indicator-overlay {
            top: 20px;
            right: 20px;
            font-size: 1.1em;
            padding: 10px 20px;
        }

        .video-player:fullscreen .video-timestamp-overlay {
            top: 20px;
            left: 20px;
            font-size: 1.1em;
            padding: 8px 15px;
        }

        .video-player.zoomed {
            cursor: grab;
        }

        .video-player.panning {
            cursor: grabbing;
        }

        .video-player video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.1s ease-out;
            transform-origin: center center;
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        .video-player.lazy-loading {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #4a9eff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .no-recording {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            text-align: center;
        }

        .timeline-panel {
            background: #2a2a2a;
            padding: 20px;
            border-top: 2px solid #333;
        }

        .playback-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }

        .play-button {
            background: #4a9eff;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 1.5em;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            flex-shrink: 0;
            position: relative;
            z-index: 10;  /* Ensure play button is above timeline elements */
        }

        .play-button:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .play-button:hover {
            background: #3a8eef;
        }

        .play-button.playing::before {
            content: '‚è∏';
        }

        .play-button.paused::before {
            content: '‚ñ∂';
        }

        .time-display {
            background: #333;
            padding: 8px 16px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            color: #4a9eff;
            min-width: 200px;
            text-align: center;
            flex-shrink: 0;
        }

        .speed-controls {
            display: flex;
            gap: 3px;
            align-items: center;
            background: #333;
            padding: 4px;
            border-radius: 4px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .speed-btn {
            background: #444;
            border: none;
            color: #aaa;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
        }

        .speed-btn:hover {
            background: #555;
        }

        .speed-btn.active {
            background: #4a9eff;
            color: white;
        }

        .timeline-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .timeline-slider-wrapper {
            position: relative;
            width: 100%;
            height: 70px;  /* Increased to accommodate markers above track */
            background: #333;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            overflow: hidden;  /* Contain all child elements */
        }

        .timeline-track {
            position: absolute;
            bottom: 15px;  /* Position track near bottom */
            left: 10px;
            right: 10px;
            height: 8px;
            background: #444;
            border-radius: 4px;
            overflow: hidden;  /* Contain segments within track */
        }

        /* Markers layer - positioned above the track */
        #timeline-markers {
            position: absolute;
            bottom: 28px;  /* Above the track */
            left: 10px;
            right: 10px;
            height: 25px;
            z-index: 5;
            pointer-events: none;
        }

        #timeline-markers .timeline-marker {
            pointer-events: auto;
        }

        .timeline-segment {
            position: absolute;
            top: 0;
            height: 100%;
            background: #4a9eff;
            opacity: 0.7;
            z-index: 1;
        }

        .timeline-segment:hover {
            opacity: 1;
            background: #5aafff;
        }

        /* SD Card recordings - orange gradient with dashed border */
        .timeline-segment.sd-card {
            background: linear-gradient(135deg, #ff9800, #ff5722);
            border: 1px dashed rgba(255, 255, 255, 0.6);
            opacity: 0.8;
        }

        .timeline-segment.sd-card:hover {
            opacity: 1;
            background: linear-gradient(135deg, #ffa726, #ff7043);
        }

        .timeline-gap {
            position: absolute;
            top: 0;
            height: 100%;
            background: #222;
            border-left: 1px solid #444;
            border-right: 1px solid #444;
        }

        .timeline-motion-marker {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(255, 165, 0, 0.5);
            width: 2px;
            pointer-events: none;
        }

        .timeline-detection-marker {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(255, 0, 0, 0.6);
            width: 3px;
            pointer-events: none;
        }

        .timeline-progress {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: rgba(74, 158, 255, 0.3);
            pointer-events: none;
            border-radius: 4px;
            transition: width 0.1s linear;
        }

        .timeline-marker {
            position: absolute;
            bottom: 0;
            height: 20px;
            min-width: 3px;
            background: #ff4a4a;
            cursor: pointer;
            border-radius: 2px 2px 0 0;
            z-index: 10;
            opacity: 0.85;
        }

        .timeline-marker:hover {
            background: #ff6a6a;
            height: 25px;
            opacity: 1;
            z-index: 11;
        }

        /* Motion event - red */
        .timeline-marker.motion {
            background: #ff4a4a;
        }

        /* Person detected - green */
        .timeline-marker.ai-person {
            background: #4caf50;
        }

        /* Vehicle detected - blue */
        .timeline-marker.ai-vehicle {
            background: #2196f3;
        }

        /* Motion visualization layer above timeline */
        .motion-visualization {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            height: 30px;
            margin-bottom: 5px;
            pointer-events: none;
        }

        .motion-bar {
            position: absolute;
            bottom: 0;
            height: 100%;
            background: linear-gradient(to top, rgba(255, 77, 77, 0.8), rgba(255, 77, 77, 0.3));
            border-radius: 2px 2px 0 0;
            transition: opacity 0.2s;
        }

        .motion-bar.low {
            height: 30%;
            background: linear-gradient(to top, rgba(76, 175, 80, 0.6), rgba(76, 175, 80, 0.2));
        }

        .motion-bar.medium {
            height: 60%;
            background: linear-gradient(to top, rgba(255, 152, 0, 0.7), rgba(255, 152, 0, 0.3));
        }

        .motion-bar.high {
            height: 100%;
            background: linear-gradient(to top, rgba(244, 67, 54, 0.8), rgba(244, 67, 54, 0.3));
        }

        .motion-bar.ai-detection {
            background: linear-gradient(to top, rgba(156, 39, 176, 0.8), rgba(156, 39, 176, 0.3));
        }

        /* Toggle button for motion visualization */
        .motion-viz-toggle {
            background: #333;
            border: 1px solid #4a9eff;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-left: 10px;
            transition: all 0.2s;
        }

        .motion-viz-toggle.active {
            background: #4a9eff;
            color: white;
        }

        .motion-viz-toggle:hover {
            background: #444;
            border-color: #5aafff;
        }

        .motion-viz-toggle.active:hover {
            background: #5aafff;
        }

        .timeline-handle {
            position: absolute;
            bottom: 11px;  /* Align with track */
            width: 16px;
            height: 16px;
            background: #4a9eff;
            border: 2px solid white;
            border-radius: 50%;
            transform: translateX(-50%);
            cursor: grab;
            z-index: 15;
            transition: transform 0.1s;
        }

        .timeline-handle:hover {
            transform: translateX(-50%) scale(1.2);
        }

        .timeline-handle:active {
            cursor: grabbing;
        }

        .timeline-time-labels {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            font-size: 0.8em;
            color: #888;
        }

        .timeline-legend {
            display: flex;
            gap: 12px;
            font-size: 0.85em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .legend-color.local {
            background: #4a9eff;
        }

        .legend-color.sd-card {
            background: linear-gradient(135deg, #ff9800, #ff5722);
            border: 1px dashed rgba(255, 255, 255, 0.5);
        }

        .legend-color.motion {
            background: #ff4a4a;
        }

        .legend-color.person {
            background: #4caf50;
        }

        .legend-color.vehicle {
            background: #2196f3;
        }

        .timeline-tooltip {
            position: absolute;
            bottom: 75px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85em;
            pointer-events: none;
            white-space: nowrap;
            display: none;
            transform: translateX(-50%);
            z-index: 20;
        }

        .timeline-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }

        .legend {
            display: flex;
            gap: 20px;
            font-size: 0.85em;
            color: #aaa;
            margin-top: 10px;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }

        .legend-events {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .detection-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #333;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .detection-toggle label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            font-size: 0.9em;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: #555;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #4a9eff;
        }

        .toggle-slider {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active .toggle-slider {
            transform: translateX(20px);
        }

        input[type="checkbox"].toggle-input {
            display: none;
        }

        .filter-divider {
            width: 1px;
            height: 20px;
            background: #555;
            margin: 0 10px;
        }

        .keyboard-hint {
            color: #666;
            font-size: 0.8em;
            cursor: help;
        }

        .keyboard-hint:hover {
            color: #4a9eff;
        }

        .shortcuts-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            border: 2px solid #4a9eff;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 1001;
            min-width: 400px;
            display: none;
        }

        .shortcuts-modal.active {
            display: block;
        }

        .shortcuts-header {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #4a9eff;
        }

        .shortcuts-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px 20px;
            margin-bottom: 20px;
        }

        .shortcut-key {
            background: #333;
            padding: 4px 8px;
            border-radius: 3px;
            font-family: monospace;
            color: #4a9eff;
            text-align: center;
        }

        .shortcut-desc {
            color: #ccc;
        }

        .camera-selector {
            background: #333;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .camera-checkbox {
            display: inline-flex;
            align-items: center;
            margin-right: 20px;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .camera-checkbox input {
            margin-right: 8px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .export-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            border: 2px solid #4a9eff;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 1000;
            min-width: 400px;
            display: none;
        }

        .export-panel.active {
            display: block;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 999;
            display: none;
        }

        .overlay.active {
            display: block;
        }

        .export-header {
            font-size: 1.3em;
            margin-bottom: 20px;
            color: #4a9eff;
        }

        .export-info {
            background: #333;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .export-info div {
            margin-bottom: 8px;
        }

        .export-info strong {
            color: #4a9eff;
        }

        .export-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-cancel {
            background: #666;
        }

        .btn-cancel:hover {
            background: #777;
        }

        .zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .video-player:hover .zoom-controls {
            opacity: 1;
        }

        .zoom-btn {
            background: rgba(74, 158, 255, 0.9);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .zoom-btn:hover {
            background: rgba(74, 158, 255, 1);
            transform: scale(1.1);
        }

        .zoom-btn.active {
            background: rgba(255, 193, 7, 0.9);
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.6);
        }

        .zoom-btn.active:hover {
            background: rgba(255, 193, 7, 1);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 10px;
            border-radius: 4px;
            color: #4a9eff;
            font-size: 0.85em;
            z-index: 5;
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .video-player:hover .zoom-indicator {
            opacity: 1;
        }

        .video-player.zoomed .zoom-indicator {
            opacity: 1;
        }

        .zoom-selection-box {
            position: absolute;
            border: 2px solid #4a9eff;
            background: rgba(74, 158, 255, 0.2);
            pointer-events: none;
            z-index: 6;
            display: none;
        }

        .zoom-selection-box.active {
            display: block;
        }

        .video-player.selecting {
            cursor: crosshair !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>üìº Playback Archive</h1>
        </div>
        <div class="stats">
            <div class="stat">
                <div class="stat-label">CPU</div>
                <div class="stat-value" id="cpu-usage">--%</div>
            </div>
            <div class="stat">
                <div class="stat-label">Memory</div>
                <div class="stat-value" id="memory-usage">--%</div>
            </div>
            <div class="stat" style="min-width: 120px;">
                <div class="stat-label">Disk</div>
                <div class="stat-value" id="disk-usage">--%</div>
                <div style="color: #666; font-size: 0.7em; margin-top: 2px;" id="disk-details">-- / -- GB</div>
            </div>
        </div>
        <div class="header-actions">
            <button class="btn" onclick="window.location.href='/'">‚Üê Live View</button>
            <button class="btn btn-success" onclick="showExportPanel()">üì• Export Recording</button>
            <button class="btn" onclick="loadTestRange()" style="background: #e74c3c;">üß™ Test 3hr</button>
        </div>
    </div>

    <!-- Timeline Selector Panel -->
    <div id="timeline-selector-panel" style="display: none;">
        <div id="timeline-selector-container"></div>
    </div>

    <div class="controls-panel" id="controls-panel" style="flex-wrap: wrap;">
        <div class="control-group">
            <label>Date</label>
            <input type="date" id="playback-date" onchange="loadRecordings()">
        </div>
        <div class="control-group">
            <label>Start Time</label>
            <input type="time" id="start-time" onchange="onStartTimeChange()">
        </div>
        <div class="control-group">
            <label>End Time</label>
            <input type="time" id="end-time" onchange="updateTimeRange()">
        </div>
        <div class="control-group">
            <label>&nbsp;</label>
            <button class="btn" onclick="toggleTimelineSelector()" id="timeline-selector-btn" title="Visual timeline selector for choosing time ranges" data-tooltip="Open visual timeline to select playback range">üìä Timeline</button>
        </div>
        <div class="control-group">
            <label>&nbsp;</label>
            <button class="btn" onclick="loadRecordings()" title="Manually refresh recordings">üîÑ Refresh</button>
        </div>
        <div class="control-group">
            <label>&nbsp;</label>
            <button class="btn" onclick="checkSDCardRecordings()" title="Check camera SD cards for recordings" style="background: #ff9800;">üíæ SD Card</button>
        </div>
        <div style="flex-basis: 100%; display: flex; gap: 8px; align-items: center; padding: 0 0 10px 0;">
            <span style="color: #888; font-size: 0.9em;">Duration:</span>
            <button class="btn" style="padding: 4px 12px; font-size: 0.85em;" onclick="setDuration(5)" title="Set end time to 5 minutes after start">+5m</button>
            <button class="btn" style="padding: 4px 12px; font-size: 0.85em;" onclick="setDuration(10)" title="Set end time to 10 minutes after start">+10m</button>
            <button class="btn" style="padding: 4px 12px; font-size: 0.85em;" onclick="setDuration(30)" title="Set end time to 30 minutes after start">+30m</button>
            <button class="btn" style="padding: 4px 12px; font-size: 0.85em;" onclick="setDuration(60)" title="Set end time to 1 hour after start">+1h</button>
        </div>
    </div>

    <div class="camera-selector" id="camera-selector">
        <strong>Select Cameras:</strong>
        <div id="camera-checkboxes" style="margin-top: 10px;">
        </div>
    </div>

    <div class="video-grid" id="video-grid">
    </div>

    <div class="timeline-panel">
        <div class="playback-controls">
            <button class="play-button paused" id="play-button" onclick="togglePlayPause()" disabled></button>

            <div class="timeline-container">
                <div class="timeline-slider-wrapper" id="timeline-slider"
                     onmousedown="startDrag(event)"
                     onmousemove="handleDrag(event)"
                     onmouseleave="hideTooltip()">
                    <!-- Markers layer above track -->
                    <div id="timeline-markers"></div>
                    <!-- Main timeline track with segments -->
                    <div class="timeline-track">
                        <div class="timeline-progress" id="timeline-progress"></div>
                    </div>
                    <div class="timeline-handle" id="timeline-handle"></div>
                    <div class="timeline-tooltip" id="timeline-tooltip">00:00:00</div>
                </div>
                <div class="timeline-time-labels">
                    <span id="start-label">--:--:--</span>
                    <span class="timeline-legend">
                        <span class="legend-item"><span class="legend-color local"></span>Local</span>
                        <span class="legend-item"><span class="legend-color sd-card"></span>SD Card</span>
                        <span class="legend-item"><span class="legend-color motion"></span>Motion</span>
                        <span class="legend-item"><span class="legend-color person"></span>Person</span>
                        <span class="legend-item"><span class="legend-color vehicle"></span>Vehicle</span>
                    </span>
                    <span id="end-label">--:--:--</span>
                </div>
            </div>

            <div class="time-display" id="current-time">
                <span id="timestamp-display" style="color: #4a9eff; font-weight: bold;">--:--:-- --</span>
                <span style="color: #666; margin: 0 8px;">|</span>
                <span id="current-time-display">--:--</span> / <span id="total-time-display">--:--</span>
            </div>

            <div class="speed-controls">
                <button class="speed-btn" onclick="setPlaybackSpeed(0.5)">0.5√ó</button>
                <button class="speed-btn active" onclick="setPlaybackSpeed(1.0)">1√ó</button>
                <button class="speed-btn" onclick="setPlaybackSpeed(1.5)">1.5√ó</button>
                <button class="speed-btn" onclick="setPlaybackSpeed(2.0)">2√ó</button>
                <button class="speed-btn" onclick="setPlaybackSpeed(4.0)">4√ó</button>
                <button class="speed-btn" onclick="setPlaybackSpeed(8.0)">8√ó</button>
            </div>
        </div>

        <div class="legend">
            <div class="legend-events">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4a9eff; width: 20px; height: 8px;"></div>
                    <span>Available Footage</span>
                </div>

                <div class="legend-item">
                    <div class="legend-color" style="background: #222; border: 1px solid #444; width: 20px; height: 8px;"></div>
                    <span>Gap (No Recording)</span>
                </div>

                <div class="filter-divider"></div>

                <div class="legend-item">
                    <div class="legend-color" style="background: #ff4a4a;"></div>
                    <span>Motion Events</span>
                </div>

                <!-- AI Detection elements (hidden when AI is disabled) -->
                <div id="ai-legend-container" style="display: none; contents;">
                    <div class="detection-toggle">
                        <label>
                            <input type="checkbox" id="show-ai-detections" class="toggle-input" checked onchange="toggleAIDetections()">
                            <div class="toggle-switch active" id="ai-toggle-switch" onclick="toggleAIToggle()">
                                <div class="toggle-slider"></div>
                            </div>
                            <span>AI Detections</span>
                        </label>
                    </div>

                    <div class="legend-item" id="person-legend">
                        <div class="legend-color" style="background: #ffa500;"></div>
                        <span>Person</span>
                    </div>
                    <div class="legend-item" id="vehicle-legend">
                        <div class="legend-color" style="background: #ffff00;"></div>
                        <span>Vehicle</span>
                    </div>
                </div>
            </div>
            <div class="keyboard-hint" onclick="showShortcuts()">
                ‚å®Ô∏è Keyboard Shortcuts
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="overlay" id="export-overlay" onclick="hideExportPanel(); hideShortcuts()"></div>
    <div class="export-panel" id="export-panel">
        <div class="export-header">üì• Export Recording</div>
        <div class="export-info">
            <div><strong>Date:</strong> <span id="export-date">--</span></div>
            <div><strong>Time Range:</strong> <span id="export-time-range">--</span></div>
            <div><strong>Cameras:</strong> <span id="export-cameras">--</span></div>
            <div><strong>Format:</strong> MP4 (H.264)</div>
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444; color: #aaa;">
                This will create a downloadable video file containing all selected cameras
                for the specified time period. The file can be saved to a USB drive or other
                portable media for law enforcement.
            </div>
        </div>
        <div class="export-actions">
            <button class="btn btn-cancel" onclick="hideExportPanel()">Cancel</button>
            <button class="btn btn-success" onclick="performExport()">Download Recording</button>
        </div>
    </div>

    <!-- Keyboard Shortcuts Modal -->
    <div class="shortcuts-modal" id="shortcuts-modal">
        <div class="shortcuts-header">‚å®Ô∏è Keyboard Shortcuts</div>
        <div class="shortcuts-grid">
            <div class="shortcut-key">Space / K</div>
            <div class="shortcut-desc">Play / Pause</div>

            <div class="shortcut-key">‚Üê / ‚Üí</div>
            <div class="shortcut-desc">Rewind / Forward 5 seconds</div>

            <div class="shortcut-key">J / L</div>
            <div class="shortcut-desc">Rewind / Forward 10 seconds</div>

            <div class="shortcut-key">0-9</div>
            <div class="shortcut-desc">Jump to 0%, 10%, 20%... of video</div>

            <div class="shortcut-key">, / .</div>
            <div class="shortcut-desc">Decrease / Increase playback speed</div>

            <div class="shortcut-key">A</div>
            <div class="shortcut-desc">Toggle AI detections (person/vehicle)</div>

            <div class="shortcut-key">?</div>
            <div class="shortcut-desc">Show this help</div>

            <div class="shortcut-key">ESC</div>
            <div class="shortcut-desc">Close modal</div>
        </div>
        <div style="text-align: right;">
            <button class="btn" onclick="hideShortcuts()">Close</button>
        </div>
    </div>

    <script>
        let cameras = [];
        let selectedCameras = new Set();
        let currentRecordings = {};
        let videoElements = {};
        let motionEvents = {};
        let playbackState = {
            playing: false,
            speed: 1.0,
            previousSpeed: 1.0,  // Track previous speed for position calculations during reload
            currentTime: 0,
            duration: 0,
            startTime: null,
            endTime: null,
            isDragging: false,
            showAIDetections: true,
            showMotionVisualization: true
        };

        async function init() {
            // Set default date to today in CST (server timezone)
            const now = new Date();
            const todayCst = now.toLocaleString('en-US', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                timeZone: 'America/Chicago'
            });
            // Convert MM/DD/YYYY to YYYY-MM-DD
            const [month, day, year] = todayCst.split('/');
            const today = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;

            // Set max date to today (prevent future date selection)
            const dateInput = document.getElementById('playback-date');
            dateInput.value = today;
            dateInput.max = today;

            // Set default time to last 10 minutes for faster loading
            setQuickRange('last-hour');

            // Check if AI detection is enabled and show/hide legend accordingly
            try {
                const configResponse = await fetch('/api/config');
                const config = await configResponse.json();
                const aiEnabled = config.ai_detection?.enabled === true;
                const motionMethod = config.motion_detection?.method || 'frame_diff';
                const showAILegend = aiEnabled || motionMethod === 'ai_only' || motionMethod === 'both';

                if (showAILegend) {
                    document.getElementById('ai-legend-container').style.display = 'contents';
                }
            } catch (e) {
                // Intentionally ignored
            }

            // Load cameras
            await loadCameras();

            // Don't load recordings automatically - wait for user to select time range
            // await loadRecordings();

            // Start fetching system stats
            fetchSystemStats();
            setInterval(fetchSystemStats, 2000); // Update every 2 seconds
        }

        async function fetchSystemStats() {
            try {
                const response = await fetch('/api/system/stats');
                const stats = await response.json();

                // Update CPU usage
                const cpuElem = document.getElementById('cpu-usage');
                if (cpuElem) {
                    cpuElem.textContent = `${stats.cpu.percent}%`;
                    cpuElem.style.color = stats.cpu.percent > 80 ? '#ff4a4a' : stats.cpu.percent > 60 ? '#ffa500' : '#4aff4a';
                }

                // Update Memory usage
                const memElem = document.getElementById('memory-usage');
                if (memElem) {
                    memElem.textContent = `${stats.memory.percent}%`;
                    memElem.style.color = stats.memory.percent > 80 ? '#ff4a4a' : stats.memory.percent > 60 ? '#ffa500' : '#4aff4a';
                }

                // Update Disk usage
                const diskElem = document.getElementById('disk-usage');
                if (diskElem) {
                    diskElem.textContent = `${stats.disk.percent}%`;
                    diskElem.style.color = stats.disk.percent > 80 ? '#ff4a4a' : stats.disk.percent > 60 ? '#ffa500' : '#4aff4a';
                }

                const diskDetailsElem = document.getElementById('disk-details');
                if (diskDetailsElem) {
                    diskDetailsElem.textContent = `${stats.disk.used_gb} / ${stats.disk.total_gb} GB`;
                }
            } catch (error) {
                console.error('Error fetching system stats:', error);
            }
        }

        // Camera ID to name lookup and reverse lookup
        let cameraNameLookup = {};
        let cameraIdLookup = {};  // Reverse lookup: name -> id

        function getCameraName(cameraId) {
            return cameraNameLookup[cameraId] || cameraId;
        }

        function getCameraId(cameraName) {
            return cameraIdLookup[cameraName] || cameraName;
        }

        async function loadCameras() {
            try {
                const response = await fetch('/api/cameras');
                cameras = await response.json();

                // Build camera name lookup and reverse lookup
                cameraNameLookup = {};
                cameraIdLookup = {};
                cameras.forEach(camera => {
                    cameraNameLookup[camera.id] = camera.name;
                    cameraIdLookup[camera.name] = camera.id;
                });

                const container = document.getElementById('camera-checkboxes');
                container.innerHTML = '';

                cameras.forEach(camera => {
                    const label = document.createElement('label');
                    label.className = 'camera-checkbox';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = camera.id;  // Use camera ID
                    checkbox.checked = false;  // No cameras selected by default
                    checkbox.onchange = () => toggleCamera(camera.id, checkbox.checked);

                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(camera.name));  // Display name
                    container.appendChild(label);

                    // Don't add to selectedCameras - user must select manually
                });

                // Show initial message prompting user to load recordings
                updateVideoGrid();

            } catch (error) {
                console.error('Error loading cameras:', error);
            }
        }

        function toggleCamera(cameraId, enabled) {
            if (enabled) {
                selectedCameras.add(cameraId);
            } else {
                selectedCameras.delete(cameraId);
            }

            // Auto-load recordings when camera selection changes
            if (selectedCameras.size > 0) {
                loadRecordings();
            } else {
                updateVideoGrid();
            }
        }

        function setQuickRange(range) {
            const now = new Date();

            // Get time in CST (server timezone) regardless of browser timezone
            const endTimeCst = now.toLocaleString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: 'America/Chicago'
            }).split(', ')[1] || now.toLocaleString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: 'America/Chicago'
            });

            let startDate;
            if (range === 'last-hour') {
                startDate = new Date(now.getTime() - 10 * 60 * 1000);  // 10 minutes ago
            } else if (range === 'last-4-hours') {
                startDate = new Date(now.getTime() - 30 * 60 * 1000);  // 30 minutes ago
            }

            const startTimeCst = startDate.toLocaleString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: 'America/Chicago'
            }).split(', ')[1] || startDate.toLocaleString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: 'America/Chicago'
            });

            document.getElementById('start-time').value = startTimeCst;
            document.getElementById('end-time').value = endTimeCst;

            // Enforce future limits (safety check)
            enforceFutureLimits();

            // Auto-load recordings when time range changes (if cameras selected)
            if (selectedCameras.size > 0) {
                loadRecordings();
            }
        }

        function enforceFutureLimits() {
            // Prevent selecting future dates/times
            const dateInput = document.getElementById('playback-date');
            const startTimeInput = document.getElementById('start-time');
            const endTimeInput = document.getElementById('end-time');

            const now = new Date();
            const todayStr = now.toLocaleDateString('en-CA'); // YYYY-MM-DD format

            // Always ensure max date is today
            dateInput.max = todayStr;

            // If date is somehow in the future, reset to today
            if (dateInput.value > todayStr) {
                dateInput.value = todayStr;
            }

            // If today is selected, limit times to current time
            if (dateInput.value === todayStr) {
                const currentTime = now.toTimeString().substring(0, 5); // HH:MM

                // If end time is in the future, cap it at current time
                if (endTimeInput.value > currentTime) {
                    endTimeInput.value = currentTime;
                }

                // If start time is in the future, cap it at current time
                if (startTimeInput.value > currentTime) {
                    startTimeInput.value = currentTime;
                }

                // Ensure start time is before end time
                if (startTimeInput.value >= endTimeInput.value) {
                    // Set start to 10 minutes before end, or beginning of day
                    const endParts = endTimeInput.value.split(':');
                    const endMinutes = parseInt(endParts[0]) * 60 + parseInt(endParts[1]);
                    const startMinutes = Math.max(0, endMinutes - 10);
                    const startHours = Math.floor(startMinutes / 60);
                    const startMins = startMinutes % 60;
                    startTimeInput.value = `${String(startHours).padStart(2, '0')}:${String(startMins).padStart(2, '0')}`;
                }
            }
        }

        function updateTimeRange() {
            // Enforce future limits first
            enforceFutureLimits();

            // Auto-load recordings when time inputs change manually
            if (selectedCameras.size > 0) {
                // Debounce to avoid loading on every keystroke
                clearTimeout(updateTimeRange.timeout);
                updateTimeRange.timeout = setTimeout(() => {
                    loadRecordings();
                }, 1000); // Wait 1 second after user stops typing
            }
        }

        function loadTestRange() {
            const now = new Date();

            // Calculate 3 hours ago and 2 hours ago in local time
            const threeHoursAgo = new Date(now.getTime() - 3 * 60 * 60 * 1000);
            const twoHoursAgo = new Date(now.getTime() - 2 * 60 * 60 * 1000);

            // Format date as YYYY-MM-DD (local date, not UTC)
            const year = threeHoursAgo.getFullYear();
            const month = String(threeHoursAgo.getMonth() + 1).padStart(2, '0');
            const day = String(threeHoursAgo.getDate()).padStart(2, '0');
            const dateStr = `${year}-${month}-${day}`;

            // Format times as HH:MM (local time)
            const startTime = String(threeHoursAgo.getHours()).padStart(2, '0') + ':' +
                             String(threeHoursAgo.getMinutes()).padStart(2, '0');
            const endTime = String(twoHoursAgo.getHours()).padStart(2, '0') + ':' +
                           String(twoHoursAgo.getMinutes()).padStart(2, '0');

            // Set the form values
            document.getElementById('playback-date').value = dateStr;
            document.getElementById('start-time').value = startTime;
            document.getElementById('end-time').value = endTime;

            // If no camera selected, select the first available
            if (selectedCameras.size === 0 && cameras.length > 0) {
                const firstCamera = cameras[0];

                // Simulate checkbox click to properly select camera
                const checkboxes = document.querySelectorAll('#camera-checkboxes input[type="checkbox"]');
                if (checkboxes.length > 0) {
                    checkboxes[0].checked = true;
                    toggleCamera(firstCamera.name, true);
                }
            }

            // Load recordings
            loadRecordings();
        }

        function setDuration(minutes) {
            const startTimeInput = document.getElementById('start-time');
            const endTimeInput = document.getElementById('end-time');
            const dateInput = document.getElementById('playback-date');

            if (!startTimeInput.value || !dateInput.value) {
                showNotification('Please select a date and start time first', 'warning');
                return;
            }

            // Parse start time in CST (add :00 for seconds if not present)
            const startTimeValue = startTimeInput.value.includes(':') && startTimeInput.value.split(':').length === 2
                ? startTimeInput.value + ':00'
                : startTimeInput.value;
            const startDateTime = `${dateInput.value}T${startTimeValue}`;
            const startDate = new Date(startDateTime);

            // Add duration
            const endDate = new Date(startDate.getTime() + minutes * 60 * 1000);

            // Format end time as HH:MM in CST
            const endTimeCst = endDate.toLocaleString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: 'America/Chicago'
            }).split(', ')[1] || endDate.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            });

            endTimeInput.value = endTimeCst;

            // Auto-load if cameras selected
            if (selectedCameras.size > 0) {
                loadRecordings();
            }
        }

        function onStartTimeChange() {
            // Auto-load recordings when start time changes
            updateTimeRange();
        }

        async function loadRecordings(includeSDCard = false) {
            // Enforce future limits before loading
            enforceFutureLimits();

            const date = document.getElementById('playback-date').value;
            const startTime = document.getElementById('start-time').value;
            const endTime = document.getElementById('end-time').value;

            if (!date || !startTime || !endTime) {
                showNotification('Please select date and time range', 'warning');
                return;
            }

            // Add :00 for seconds if not present (time inputs without step attribute return HH:MM)
            const startTimeWithSeconds = startTime.split(':').length === 2 ? startTime + ':00' : startTime;
            const endTimeWithSeconds = endTime.split(':').length === 2 ? endTime + ':00' : endTime;

            const startDateTime = `${date}T${startTimeWithSeconds}`;
            const endDateTime = `${date}T${endTimeWithSeconds}`;

            try {
                // Load recordings for all cameras
                let url = `/api/playback/recordings?start_time=${encodeURIComponent(startDateTime)}&end_time=${encodeURIComponent(endDateTime)}`;
                if (includeSDCard) {
                    url += '&include_sd_card=true';
                }

                const response = await fetch(url);
                const data = await response.json();

                currentRecordings = data.cameras;

                // Check for SD card recordings
                if (data.sd_card_segments) {
                    const sdCardCount = Object.values(data.sd_card_segments).reduce((sum, count) => sum + count, 0);
                    if (sdCardCount > 0) {
                        showNotification(`Loaded ${sdCardCount} SD card recording(s)`, 'info', 4000);
                    }
                }

                // Check if any recordings exist for the selected date/time range
                const totalSegments = Object.values(currentRecordings).reduce(
                    (sum, segments) => sum + (segments ? segments.length : 0), 0
                );
                if (totalSegments === 0) {
                    // Offer to check SD card if no local recordings
                    showNotification(`No local recordings for ${date}. Click "Check SD Card" to look for camera storage.`, 'warning', 8000);
                }

                // Load motion events
                const motionResponse = await fetch(
                    `/api/playback/motion-events?start_time=${encodeURIComponent(startDateTime)}&end_time=${encodeURIComponent(endDateTime)}`
                );
                const motionData = await motionResponse.json();
                motionEvents = motionData.cameras;

                // Store time range in playback state
                playbackState.startTime = startDateTime;
                playbackState.endTime = endDateTime;

                // Update UI
                updateVideoGrid();
                updateTimeline();

            } catch (error) {
                console.error('Error loading recordings:', error);
                showNotification('Error loading recordings: ' + error.message, 'error');
            }
        }

        async function checkSDCardRecordings() {
            if (selectedCameras.size === 0) {
                showNotification('Please select at least one camera first', 'warning');
                return;
            }

            const date = document.getElementById('playback-date').value;
            const startTime = document.getElementById('start-time').value;
            const endTime = document.getElementById('end-time').value;

            if (!date || !startTime || !endTime) {
                showNotification('Please set date and time range first', 'warning');
                return;
            }

            showNotification('Checking camera SD cards for missing recordings...', 'info');

            try {
                const startDateTime = `${date}T${startTime}:00`;
                const endDateTime = `${date}T${endTime}:00`;
                const cameras = Array.from(selectedCameras).join(',');

                const response = await fetch(
                    `/api/playback/sd-card-gaps?start_time=${encodeURIComponent(startDateTime)}&end_time=${encodeURIComponent(endDateTime)}&cameras=${encodeURIComponent(cameras)}`
                );

                if (!response.ok) {
                    throw new Error('Failed to check SD cards');
                }

                const data = await response.json();

                if (!data.success) {
                    showNotification('Error checking SD cards: ' + (data.error || 'Unknown error'), 'error');
                    return;
                }

                // Process results
                let totalGaps = 0;
                let sdRecordingsFound = 0;
                let camerasWithSDSupport = 0;

                Object.entries(data.cameras).forEach(([cameraId, result]) => {
                    if (result.has_gaps) {
                        totalGaps += result.gap_count;
                    }
                    if (result.sd_recordings && result.sd_recordings.length > 0) {
                        sdRecordingsFound += result.sd_recordings.length;

                        // Merge SD recordings into currentRecordings
                        if (!currentRecordings[cameraId]) {
                            currentRecordings[cameraId] = [];
                        }

                        result.sd_recordings.forEach(sdRec => {
                            // Add SD card recording with source marker
                            currentRecordings[cameraId].push({
                                start_time: sdRec.start_time,
                                end_time: sdRec.end_time,
                                source: 'sd_card',
                                recording_token: sdRec.recording_token
                            });
                        });

                        // Sort recordings by start time
                        currentRecordings[cameraId].sort((a, b) =>
                            new Date(a.start_time).getTime() - new Date(b.start_time).getTime()
                        );
                    }
                    if (result.supports_sd_card) {
                        camerasWithSDSupport++;
                    }
                });

                // Update timeline with new recordings
                updateTimeline();

                // Show results
                if (sdRecordingsFound > 0) {
                    showNotification(
                        `Found ${sdRecordingsFound} SD card recording(s) to fill ${totalGaps} gap(s). ` +
                        `Orange segments on timeline are from SD card.`,
                        'success'
                    );
                } else if (totalGaps > 0) {
                    if (camerasWithSDSupport === 0) {
                        showNotification(
                            `Found ${totalGaps} gap(s) but no cameras support SD card access (Profile G).`,
                            'warning'
                        );
                    } else {
                        showNotification(
                            `Found ${totalGaps} gap(s) but no SD card recordings available to fill them.`,
                            'info'
                        );
                    }
                } else {
                    showNotification('No gaps found in local recordings!', 'success');
                }

            } catch (error) {
                console.error('Error checking SD cards:', error);
                showNotification('Error checking SD cards: ' + error.message, 'error');
            }
        }

        function updateVideoGrid() {
            const grid = document.getElementById('video-grid');
            grid.innerHTML = '';
            videoElements = {};

            // Show message if no recordings have been loaded yet
            if (!currentRecordings || Object.keys(currentRecordings).length === 0) {
                grid.innerHTML = '<div class="no-recording" style="grid-column: 1 / -1; text-align: center; padding: 4rem 2rem; font-size: 1.2em;">Select one or more cameras above to automatically load recordings</div>';
                return;
            }

            selectedCameras.forEach(cameraId => {
                const cameraName = getCameraName(cameraId);
                const safeId = cameraId.replace(/[^a-zA-Z0-9-_]/g, '_');
                const container = document.createElement('div');
                container.className = 'video-container';

                const header = document.createElement('div');
                header.className = 'video-header';
                header.innerHTML = `
                    <span class="video-name">${cameraName}</span>
                    <span style="font-size: 0.9em; color: #888;">
                        ${currentRecordings[cameraId] ?
                            `${currentRecordings[cameraId].length} segments` :
                            'No recordings'}
                    </span>
                `;

                const player = document.createElement('div');
                player.className = 'video-player';

                if (currentRecordings[cameraId] && currentRecordings[cameraId].length > 0) {
                    const video = document.createElement('video');
                    video.controls = false;  // Hide native controls - we have our own timeline
                    video.preload = 'metadata';  // Preload metadata for instant playback
                    video.autoplay = true;  // Auto-start video when loaded
                    video.muted = true;  // Muted by default (required for autoplay in modern browsers)
                    video.playsInline = true;  // Required for iOS
                    video.id = `video-${safeId}`;
                    video.dataset.cameraId = cameraId;

                    // Use playback API to serve video
                    const startTime = document.getElementById('start-time').value;
                    const endTime = document.getElementById('end-time').value;
                    const date = document.getElementById('playback-date').value;

                    // Add :00 for seconds if not present
                    const startTimeWithSeconds = startTime.split(':').length === 2 ? startTime + ':00' : startTime;
                    const endTimeWithSeconds = endTime.split(':').length === 2 ? endTime + ':00' : endTime;

                    const startDateTime = `${date}T${startTimeWithSeconds}`;
                    const endDateTime = `${date}T${endTimeWithSeconds}`;

                    // Use API endpoint to serve video properly
                    // Add cache-buster to force reload when time range changes
                    const cacheBuster = Date.now();
                    const videoUrl = `/api/playback/video/${encodeURIComponent(cameraId)}?start_time=${encodeURIComponent(startDateTime)}&end_time=${encodeURIComponent(endDateTime)}&_=${cacheBuster}`;

                    video.onloadeddata = () => {
                        // Clear player and add video
                        player.innerHTML = '';
                        player.appendChild(video);

                        // Add zoom controls after video loads
                        const zoomIndicator = document.createElement('div');
                        zoomIndicator.className = 'zoom-indicator';
                        zoomIndicator.id = `zoom-indicator-${safeId}`;
                        zoomIndicator.textContent = '100%';

                        const zoomControls = document.createElement('div');
                        zoomControls.className = 'zoom-controls';
                        zoomControls.innerHTML = `
                            <button class="zoom-btn select-area-btn" data-camera="${cameraId}" title="Select Area to Zoom">‚ä°</button>
                            <button class="zoom-btn" onclick="zoomVideo('${cameraId}', 'in')" title="Zoom In (+)">+</button>
                            <button class="zoom-btn" onclick="zoomVideo('${cameraId}', 'out')" title="Zoom Out (-)">‚àí</button>
                            <button class="zoom-btn" onclick="zoomVideo('${cameraId}', 'reset')" title="Reset Zoom (0)">‚åÇ</button>
                            <button class="zoom-btn" onclick="enterFullscreenPlayback('${cameraId}')" title="Fullscreen (F)">‚õ∂</button>
                        `;

                        const selectionBox = document.createElement('div');
                        selectionBox.className = 'zoom-selection-box';
                        selectionBox.id = `zoom-selection-${safeId}`;

                        // Add timestamp overlay
                        const timestampOverlay = document.createElement('div');
                        timestampOverlay.className = 'video-timestamp-overlay';
                        timestampOverlay.id = `timestamp-${safeId}`;
                        timestampOverlay.textContent = '--:--:--';

                        // Add motion indicator overlay
                        const motionOverlay = document.createElement('div');
                        motionOverlay.className = 'motion-indicator-overlay';
                        motionOverlay.id = `motion-indicator-${safeId}`;
                        motionOverlay.innerHTML = '<span class="motion-icon"></span><span class="motion-text">MOTION</span>';

                        player.appendChild(zoomIndicator);
                        player.appendChild(zoomControls);
                        player.appendChild(selectionBox);
                        player.appendChild(timestampOverlay);
                        player.appendChild(motionOverlay);

                        // Add zoom data to player
                        player.dataset.zoomScale = '1';
                        player.dataset.zoomX = '0';
                        player.dataset.zoomY = '0';
                    };

                    // Set video source - this triggers loading
                    video.src = videoUrl;
                    video.playbackRate = playbackState.speed;

                    // Update timestamp overlay as video plays
                    video.ontimeupdate = () => {
                        updateVideoTimestamp(cameraId, video);
                    };

                    // Auto-skip to next segment when current segment ends
                    video.onended = () => {
                        skipToNextSegment(cameraId);
                    };

                    // Double-click to enter fullscreen
                    video.ondblclick = () => {
                        enterFullscreenPlayback(cameraId);
                    };

                    // Handle errors
                    video.onerror = () => {
                        player.innerHTML = '<div class="no-recording">Error loading video. Check console for details.</div>';
                        console.error(`Failed to load video for ${cameraName} (id: ${cameraId}):`, video.error);
                    };

                    videoElements[cameraId] = video;
                } else {
                    player.innerHTML = '<div class="no-recording">No recording available for this time period</div>';
                }

                container.appendChild(header);
                container.appendChild(player);
                grid.appendChild(container);
            });

            // Enable play button if videos were loaded
            const playButton = document.getElementById('play-button');
            if (Object.keys(videoElements).length > 0) {
                playButton.disabled = false;
            } else {
                playButton.disabled = true;
            }
        }

        function updateTimeline() {
            const markersContainer = document.getElementById('timeline-markers');
            const timelineTrack = document.querySelector('.timeline-track');

            // Clear existing markers and segments
            markersContainer.innerHTML = '';

            // Remove old segments and gaps
            timelineTrack.querySelectorAll('.timeline-segment, .timeline-gap').forEach(el => el.remove());

            if (!playbackState.startTime || !playbackState.endTime) return;

            const startMs = new Date(playbackState.startTime).getTime();
            const endMs = new Date(playbackState.endTime).getTime();
            const rangeMs = endMs - startMs;

            // Render segments and gaps for each selected camera
            selectedCameras.forEach(cameraId => {
                const cameraName = getCameraName(cameraId);
                if (!currentRecordings[cameraId]) return;

                const segments = currentRecordings[cameraId];

                // Sort segments by start time
                const sortedSegments = [...segments].sort((a, b) =>
                    new Date(a.start_time).getTime() - new Date(b.start_time).getTime()
                );

                // Render each segment
                sortedSegments.forEach((segment, index) => {
                    const segmentStartMs = new Date(segment.start_time).getTime();
                    const segmentEndMs = new Date(segment.end_time).getTime();

                    // Calculate position and width as percentage
                    const startPercent = Math.max(0, ((segmentStartMs - startMs) / rangeMs) * 100);
                    const endPercent = Math.min(100, ((segmentEndMs - startMs) / rangeMs) * 100);
                    const widthPercent = endPercent - startPercent;

                    if (widthPercent > 0) {
                        const segmentEl = document.createElement('div');
                        segmentEl.className = 'timeline-segment';

                        // Check if this is an SD card recording
                        if (segment.source === 'sd_card') {
                            segmentEl.classList.add('sd-card');
                            segmentEl.title = `SD Card - ${cameraName}: ${formatTime(segment.start_time)} - ${formatTime(segment.end_time)}`;
                        } else {
                            segmentEl.title = `${cameraName}: ${formatTime(segment.start_time)} - ${formatTime(segment.end_time)}`;
                        }

                        segmentEl.style.left = startPercent + '%';
                        segmentEl.style.width = widthPercent + '%';
                        // Remove segment onclick - let the timeline slider handle all seeks
                        // segmentEl.onclick = () => seekToTime(segmentStartMs);
                        timelineTrack.appendChild(segmentEl);
                    }

                    // Render gap between this segment and next
                    if (index < sortedSegments.length - 1) {
                        const nextSegment = sortedSegments[index + 1];
                        const gapStartMs = segmentEndMs;
                        const gapEndMs = new Date(nextSegment.start_time).getTime();

                        const gapStartPercent = ((gapStartMs - startMs) / rangeMs) * 100;
                        const gapEndPercent = ((gapEndMs - startMs) / rangeMs) * 100;
                        const gapWidthPercent = gapEndPercent - gapStartPercent;

                        if (gapWidthPercent > 0.1) { // Only show gaps > 0.1%
                            const gapEl = document.createElement('div');
                            gapEl.className = 'timeline-gap';
                            gapEl.style.left = gapStartPercent + '%';
                            gapEl.style.width = gapWidthPercent + '%';
                            const gapDuration = Math.round((gapEndMs - gapStartMs) / 1000);
                            gapEl.title = `Gap: ${gapDuration}s (no recording)`;
                            timelineTrack.appendChild(gapEl);
                        }
                    }
                });
            });

            // Helper function to check if an event time falls within any recording segment
            function isTimeWithinSegments(eventTimeMs, segments) {
                if (!segments || segments.length === 0) return false;
                return segments.some(seg => {
                    const segStart = new Date(seg.start_time).getTime();
                    const segEnd = new Date(seg.end_time).getTime();
                    return eventTimeMs >= segStart && eventTimeMs <= segEnd;
                });
            }

            // Add motion event markers
            Object.keys(motionEvents).forEach(cameraName => {
                const cameraId = getCameraId(cameraName);
                if (!selectedCameras.has(cameraId)) return;

                const cameraSegments = currentRecordings[cameraId] || [];

                motionEvents[cameraName].forEach(event => {
                    // Filter based on AI detection toggle
                    const isAIDetection = event.event_type === 'ai_person' || event.event_type === 'ai_vehicle';
                    if (isAIDetection && !playbackState.showAIDetections) {
                        return; // Skip AI detections if toggle is off
                    }

                    const eventTime = new Date(event.event_time).getTime();

                    // Only show events that fall within available recording segments
                    if (!isTimeWithinSegments(eventTime, cameraSegments)) {
                        return; // Skip events where no recording exists
                    }

                    const position = ((eventTime - startMs) / rangeMs) * 100;

                    if (position >= 0 && position <= 100) {
                        const marker = document.createElement('div');
                        marker.className = 'timeline-marker';

                        // Calculate width based on duration (if available)
                        const durationSecs = event.duration_seconds || 1;
                        const durationMs = durationSecs * 1000;
                        let widthPercent = (durationMs / rangeMs) * 100;
                        // Minimum width for visibility, cap at reasonable max
                        widthPercent = Math.max(0.1, Math.min(widthPercent, 5));

                        // Format duration for tooltip
                        const durationStr = durationSecs >= 60
                            ? `${Math.floor(durationSecs / 60)}m ${Math.round(durationSecs % 60)}s`
                            : `${Math.round(durationSecs)}s`;

                        // Different colors for different event types
                        if (event.event_type === 'ai_person') {
                            marker.classList.add('ai-person');
                            marker.title = `Person detected: ${cameraName} at ${formatTime(event.event_time)} (${durationStr})`;
                        } else if (event.event_type === 'ai_vehicle') {
                            marker.classList.add('ai-vehicle');
                            marker.title = `Vehicle detected: ${cameraName} at ${formatTime(event.event_time)} (${durationStr})`;
                        } else {
                            marker.classList.add('motion');
                            marker.title = `Motion: ${cameraName} at ${formatTime(event.event_time)} (${durationStr})`;
                        }

                        marker.style.left = position + '%';
                        marker.style.width = widthPercent + '%';
                        // Remove marker onclick - let the timeline slider handle all seeks
                        // marker.onclick = () => seekToTime(eventTime);
                        markersContainer.appendChild(marker);
                    }
                });
            });

            // Render motion visualization bars
            renderMotionVisualization();

            // Update time labels
            document.getElementById('start-label').textContent = formatTime(playbackState.startTime);
            document.getElementById('end-label').textContent = formatTime(playbackState.endTime);
            document.getElementById('total-time-display').textContent = formatDuration(rangeMs / 1000);
        }

        function renderMotionVisualization() {
            const vizContainer = document.getElementById('motion-visualization');
            if (!vizContainer) return;

            // Clear existing bars
            vizContainer.innerHTML = '';

            // Don't render if visualization is disabled
            if (!playbackState.showMotionVisualization) {
                vizContainer.style.display = 'none';
                return;
            }
            vizContainer.style.display = 'block';

            if (!playbackState.startTime || !playbackState.endTime) return;

            const startMs = new Date(playbackState.startTime).getTime();
            const endMs = new Date(playbackState.endTime).getTime();
            const rangeMs = endMs - startMs;

            // Group motion events into time buckets for visualization
            const bucketSize = Math.max(5000, rangeMs / 100); // At least 5 seconds, max 100 buckets
            const buckets = new Map();

            // Helper to check if time is within recording segments
            function isTimeWithinRecordings(timeMs, cameraId) {
                const segments = currentRecordings[cameraId] || [];
                return segments.some(seg => {
                    const segStart = new Date(seg.start_time).getTime();
                    const segEnd = new Date(seg.end_time).getTime();
                    return timeMs >= segStart && timeMs <= segEnd;
                });
            }

            // Collect all motion events across selected cameras
            Object.keys(motionEvents).forEach(cameraName => {
                const cameraId = getCameraId(cameraName);
                if (!selectedCameras.has(cameraId)) return;

                motionEvents[cameraName].forEach(event => {
                    const eventTime = new Date(event.event_time).getTime();

                    // Only include events within available recordings
                    if (!isTimeWithinRecordings(eventTime, cameraId)) {
                        return;
                    }

                    // Calculate which bucket this event belongs to
                    const bucketIndex = Math.floor((eventTime - startMs) / bucketSize);

                    if (!buckets.has(bucketIndex)) {
                        buckets.set(bucketIndex, {
                            count: 0,
                            hasAI: false,
                            startTime: startMs + (bucketIndex * bucketSize),
                            endTime: startMs + ((bucketIndex + 1) * bucketSize)
                        });
                    }

                    const bucket = buckets.get(bucketIndex);
                    bucket.count++;

                    // Check if this bucket has AI detections
                    const isAIDetection = event.event_type === 'ai_person' || event.event_type === 'ai_vehicle';
                    if (isAIDetection) {
                        bucket.hasAI = true;
                    }
                });
            });

            // Render motion bars
            buckets.forEach((bucket, index) => {
                const position = ((bucket.startTime - startMs) / rangeMs) * 100;
                const width = (bucketSize / rangeMs) * 100;

                if (position >= 0 && position <= 100) {
                    const bar = document.createElement('div');
                    bar.className = 'motion-bar';

                    // Determine intensity level
                    if (bucket.hasAI) {
                        bar.classList.add('ai-detection');
                        bar.title = `AI Detection (${bucket.count} events)`;
                    } else if (bucket.count >= 5) {
                        bar.classList.add('high');
                        bar.title = `High Motion (${bucket.count} events)`;
                    } else if (bucket.count >= 2) {
                        bar.classList.add('medium');
                        bar.title = `Medium Motion (${bucket.count} events)`;
                    } else {
                        bar.classList.add('low');
                        bar.title = `Low Motion (${bucket.count} event${bucket.count > 1 ? 's' : ''})`;
                    }

                    bar.style.left = position + '%';
                    bar.style.width = width + '%';

                    vizContainer.appendChild(bar);
                }
            });
        }

        function toggleMotionVisualization() {
            playbackState.showMotionVisualization = !playbackState.showMotionVisualization;
            renderMotionVisualization();
        }

        function toggleMotionVizSwitch() {
            const checkbox = document.getElementById('show-motion-viz');
            const toggleSwitch = document.getElementById('motion-viz-switch');

            checkbox.checked = !checkbox.checked;
            playbackState.showMotionVisualization = checkbox.checked;

            if (checkbox.checked) {
                toggleSwitch.classList.add('active');
            } else {
                toggleSwitch.classList.remove('active');
            }

            renderMotionVisualization();
        }

        function formatTime(isoString) {
            if (!isoString) return '--:--:--';
            return new Date(isoString).toLocaleTimeString();
        }

        function formatDuration(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function updateVideoTimestamp(cameraName, video) {
            const overlay = document.getElementById(`timestamp-${cameraName}`);
            if (!overlay) return;

            // Get the current segment being played
            if (!currentRecordings[cameraName] || currentRecordings[cameraName].length === 0) {
                overlay.textContent = '--:--:--';
                return;
            }

            // Parse the video source to find which segment is playing
            const videoSrc = video.src;
            const startTimeMatch = videoSrc.match(/start_time=([^&]+)/);

            if (startTimeMatch) {
                const segmentStartTime = decodeURIComponent(startTimeMatch[1]);

                // Parse as local time (no timezone conversion)
                const segmentStartMs = new Date(segmentStartTime).getTime();
                const currentTimeMs = segmentStartMs + (video.currentTime * 1000);
                const currentDate = new Date(currentTimeMs);

                // Format as local time with MM/DD/YYYY, HH:MM:SS
                const formatted = currentDate.toLocaleString('en-US', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });

                overlay.textContent = formatted;

                // Also check for motion events at current time
                updateMotionIndicator(cameraName, currentTimeMs);
            }
        }

        function updateMotionIndicator(cameraId, currentTimeMs) {
            const safeId = cameraId.replace(/[^a-zA-Z0-9-_]/g, '_');
            const indicator = document.getElementById(`motion-indicator-${safeId}`);
            if (!indicator) return;

            // Check if there's a motion event within 2 seconds of current time
            const events = motionEvents[cameraId] || [];
            const threshold = 2000; // 2 second window

            let matchingEvent = null;
            for (const event of events) {
                const eventTime = new Date(event.event_time).getTime();
                if (Math.abs(eventTime - currentTimeMs) <= threshold) {
                    matchingEvent = event;
                    break;
                }
            }

            if (matchingEvent) {
                indicator.classList.add('active');

                // Update indicator type based on event type
                indicator.classList.remove('ai-person', 'ai-vehicle');
                if (matchingEvent.event_type === 'ai_person') {
                    indicator.classList.add('ai-person');
                    indicator.querySelector('.motion-text').textContent = 'PERSON';
                } else if (matchingEvent.event_type === 'ai_vehicle') {
                    indicator.classList.add('ai-vehicle');
                    indicator.querySelector('.motion-text').textContent = 'VEHICLE';
                } else {
                    indicator.querySelector('.motion-text').textContent = 'MOTION';
                }
            } else {
                indicator.classList.remove('active', 'ai-person', 'ai-vehicle');
            }
        }

        function skipToNextSegment(cameraName) {
            // Get segments for this camera
            const segments = currentRecordings[cameraName];
            if (!segments || segments.length === 0) {
                return;
            }

            // Get current video element
            const video = videoElements[cameraName];
            if (!video) return;

            // Parse current segment start time from video source
            const videoSrc = video.src;
            const startTimeMatch = videoSrc.match(/start_time=([^&]+)/);
            if (!startTimeMatch) {
                return;
            }

            const currentSegmentStart = decodeURIComponent(startTimeMatch[1]);
            const currentSegmentMs = new Date(currentSegmentStart).getTime();

            // Find next segment after current one
            const sortedSegments = [...segments].sort((a, b) =>
                new Date(a.start_time).getTime() - new Date(b.start_time).getTime()
            );

            let nextSegment = null;
            for (const segment of sortedSegments) {
                const segmentMs = new Date(segment.start_time).getTime();
                if (segmentMs > currentSegmentMs) {
                    nextSegment = segment;
                    break;
                }
            }

            if (nextSegment) {
                // Calculate gap duration
                const gapStart = new Date(videoSrc.match(/end_time=([^&]+)/)?.[1] || currentSegmentStart);
                const gapEnd = new Date(nextSegment.start_time);
                const gapSeconds = Math.round((gapEnd - gapStart) / 1000);

                // Load next segment
                const cacheBuster = Date.now();
                const endDateTime = playbackState.endTime;
                const newSrc = `/api/playback/video/${encodeURIComponent(cameraName)}?start_time=${encodeURIComponent(nextSegment.start_time)}&end_time=${encodeURIComponent(endDateTime)}&_=${cacheBuster}`;

                // Update video source and play
                video.src = newSrc;
                video.playbackRate = playbackState.speed;
                if (playbackState.playing) {
                    video.play();
                }
            } else {
                // Pause playback when we reach the end
                playbackState.playing = false;
                const playButton = document.getElementById('play-button');
                playButton.classList.remove('playing');
                playButton.classList.add('paused');
            }
        }

        function togglePlayPause() {
            playbackState.playing = !playbackState.playing;
            updatePlayPauseButton();

            Object.values(videoElements).forEach(video => {
                if (playbackState.playing) {
                    video.play().catch(err => {
                        console.error('Failed to play video:', err);
                        // Revert play state on error
                        playbackState.playing = false;
                        updatePlayPauseButton();
                    });
                } else {
                    video.pause();
                }
            });
        }

        function updatePlayPauseButton() {
            const playButton = document.getElementById('play-button');
            if (playbackState.playing) {
                playButton.classList.remove('paused');
                playButton.classList.add('playing');
            } else {
                playButton.classList.remove('playing');
                playButton.classList.add('paused');
            }
        }

        function setPlaybackSpeed(speed) {
            const previousSpeed = playbackState.speed;
            playbackState.speed = speed;

            // For speeds > 2x, we need server-side processing
            // The server will create a sped-up version of the video
            const needsServerSpeed = speed > 2.0;
            const hadServerSpeed = previousSpeed > 2.0;

            // Check if we need to reload videos due to crossing the 2x threshold
            // or changing between different high-speed values (4x vs 8x)
            if (needsServerSpeed !== hadServerSpeed || (needsServerSpeed && speed !== previousSpeed)) {
                // Reload all videos with new speed parameter
                reloadVideosWithSpeed(speed);
            } else {
                // For speeds <= 2x, use browser playbackRate
                Object.values(videoElements).forEach(video => {
                    video.playbackRate = speed;
                });
            }

            // Update UI buttons
            updateSpeedButtons(speed);
        }

        function reloadVideosWithSpeed(speed) {
            // Show loading notification for server-side speed processing
            if (speed > 2.0) {
                showNotification(`Loading ${speed}x speed video...`);
            }

            // Get current playback position
            const wasPlaying = playbackState.playing;

            // For each video, update the source URL with the speed parameter
            Object.entries(videoElements).forEach(([cameraId, video]) => {
                const currentSrc = video.src;
                if (!currentSrc) return;

                // Parse current URL and update/add speed parameter
                const url = new URL(currentSrc, window.location.origin);

                // Update or add speed parameter
                if (speed > 2.0) {
                    url.searchParams.set('speed', speed.toString());
                } else {
                    url.searchParams.delete('speed');
                }

                // Update cache buster
                url.searchParams.set('_', Date.now().toString());

                // Store current time to restore position
                const currentTime = video.currentTime;

                // Set new source
                video.src = url.toString();

                // For server-processed speed videos, browser rate should be 1.0
                // For normal videos, use the requested speed
                video.playbackRate = speed > 2.0 ? 1.0 : speed;

                // Restore position and play state when metadata loads
                video.onloadedmetadata = () => {
                    // For sped-up videos, the duration is shorter
                    // Adjust seek position proportionally
                    if (speed > 2.0 && playbackState.previousSpeed <= 2.0) {
                        // Going from normal to fast: position stays same (server video is shorter)
                        video.currentTime = Math.min(currentTime, video.duration);
                    } else if (speed <= 2.0 && playbackState.previousSpeed > 2.0) {
                        // Going from fast to normal: scale position back
                        video.currentTime = Math.min(currentTime * playbackState.previousSpeed, video.duration);
                    } else {
                        // Changing between fast speeds (4x <-> 8x)
                        const ratio = playbackState.previousSpeed / speed;
                        video.currentTime = Math.min(currentTime * ratio, video.duration);
                    }

                    if (wasPlaying) {
                        video.play().catch(err => console.warn('Failed to resume playback:', err));
                    }
                };
            });

            // Store previous speed for position calculations
            playbackState.previousSpeed = speed;
        }

        // Timeline slider interaction
        let mouseDownX = 0;
        let mouseDownTime = 0;
        let isDragging = false;

        function startDrag(event) {
            mouseDownX = event.clientX;
            mouseDownTime = Date.now();
            isDragging = false;
            playbackState.isDragging = true;
        }

        function handleDrag(event) {
            if (playbackState.isDragging) {
                // Check if mouse moved enough to be dragging
                const moved = Math.abs(event.clientX - mouseDownX);
                if (moved > 3) {
                    isDragging = true;
                    seekToPosition(event);
                }
            }
            showTooltip(event);
        }

        function stopDrag(event) {
            if (playbackState.isDragging) {
                const moved = Math.abs(event.clientX - mouseDownX);
                const duration = Date.now() - mouseDownTime;

                // Always seek on mouseup (whether click or drag end)
                // This ensures we seek exactly once for clicks
                seekToPosition(event);

                playbackState.isDragging = false;
                isDragging = false;
            }
        }

        // Add mouseup listener to stop dragging
        document.addEventListener('mouseup', stopDrag);

        function seekToPosition(event) {
            const slider = document.getElementById('timeline-slider');
            const rect = slider.getBoundingClientRect();
            const padding = 10; // Timeline track has 10px padding on each side

            // Calculate position relative to the actual track (accounting for padding)
            const x = event.clientX - rect.left - padding;
            const trackWidth = rect.width - (padding * 2);
            let percent = (x / trackWidth) * 100;

            // Clamp between 0 and 100
            percent = Math.max(0, Math.min(100, percent));

            if (!playbackState.startTime || !playbackState.endTime) return;

            const startMs = new Date(playbackState.startTime).getTime();
            const endMs = new Date(playbackState.endTime).getTime();
            const rangeMs = endMs - startMs;
            let targetTimeMs = startMs + (rangeMs * percent / 100);

            // Check if clicked time falls within any segment across selected cameras
            let hasValidSegment = false;
            let nearestSegmentTime = null;
            let nearestDistance = Infinity;

            selectedCameras.forEach(cameraName => {
                const segments = currentRecordings[cameraName] || [];
                segments.forEach(seg => {
                    const segStart = new Date(seg.start_time).getTime();
                    const segEnd = new Date(seg.end_time).getTime();

                    // Check if target is within this segment
                    if (targetTimeMs >= segStart && targetTimeMs < segEnd) {
                        hasValidSegment = true;
                    }

                    // Track nearest segment boundary for snapping
                    const distToStart = Math.abs(targetTimeMs - segStart);
                    const distToEnd = Math.abs(targetTimeMs - segEnd);

                    if (distToStart < nearestDistance) {
                        nearestDistance = distToStart;
                        nearestSegmentTime = segStart;
                    }
                    if (distToEnd < nearestDistance) {
                        nearestDistance = distToEnd;
                        nearestSegmentTime = segEnd;
                    }
                });
            });

            // If no valid segment at clicked position, snap to nearest segment
            if (!hasValidSegment && nearestSegmentTime !== null) {
                targetTimeMs = nearestSegmentTime;
                // Recalculate percent for the snapped position
                percent = ((targetTimeMs - startMs) / rangeMs) * 100;
            }

            // If still no valid segment (no recordings at all), don't seek
            if (!hasValidSegment && nearestSegmentTime === null) {
                return;
            }

            updateTimelinePosition(percent);
            playbackState.currentTime = (targetTimeMs - startMs) / 1000;

            // Seek to the target time
            seekToTime(targetTimeMs);
        }

        function seekToTime(timestampMs) {
            if (!playbackState.startTime || !playbackState.endTime) return;

            const startMs = new Date(playbackState.startTime).getTime();
            const endMs = new Date(playbackState.endTime).getTime();
            const rangeMs = endMs - startMs;
            const percent = ((timestampMs - startMs) / rangeMs) * 100;

            const clickedDate = new Date(timestampMs);

            updateTimelinePosition(percent);
            playbackState.currentTime = (timestampMs - startMs) / 1000;

            // For each camera, load the appropriate segment and seek within it
            selectedCameras.forEach(cameraName => {
                const video = videoElements[cameraName];
                if (!video || !currentRecordings[cameraName]) return;

                const segments = currentRecordings[cameraName];

                // Find segment that contains this timestamp
                // Prefer segment that starts exactly at the timestamp (avoids boundary issues)
                let matchingSegment = segments.find(seg => {
                    const segStart = new Date(seg.start_time).getTime();
                    return segStart === timestampMs;
                });

                // If no exact start match, find segment that contains the timestamp
                // Use exclusive end boundary to avoid matching two segments at boundary
                if (!matchingSegment) {
                    matchingSegment = segments.find(seg => {
                        const segStart = new Date(seg.start_time).getTime();
                        const segEnd = new Date(seg.end_time).getTime();
                        return timestampMs >= segStart && timestampMs < segEnd;
                    });
                }

                if (matchingSegment) {
                    const segmentStart = matchingSegment.start_time.replace(' ', 'T');
                    const segmentEnd = matchingSegment.end_time.replace(' ', 'T');
                    const segmentStartMs = new Date(matchingSegment.start_time).getTime();

                    // Calculate offset within this segment (in seconds)
                    const offsetSeconds = (timestampMs - segmentStartMs) / 1000;

                    // Build URL for this specific segment
                    const cacheBuster = Date.now();
                    const newSrc = `/api/playback/video/${encodeURIComponent(cameraName)}?start_time=${encodeURIComponent(segmentStart)}&end_time=${encodeURIComponent(segmentEnd)}&_=${cacheBuster}`;

                    // Check if we're already showing this segment by comparing timestamps
                    const currentSrc = video.src;
                    let needsReload = true;

                    if (currentSrc) {
                        const currentSegmentMatch = currentSrc.match(/start_time=([^&]+)/);
                        if (currentSegmentMatch) {
                            const currentSegmentStart = decodeURIComponent(currentSegmentMatch[1]);
                            // Normalize both times to timestamps for accurate comparison
                            const currentSegmentStartMs = new Date(currentSegmentStart).getTime();

                            // If timestamps match (within 1 second tolerance), it's the same segment
                            needsReload = Math.abs(currentSegmentStartMs - segmentStartMs) > 1000;
                        }
                    }

                    if (!needsReload) {
                        // Same segment, just seek within current video
                        // Wait for video to be ready before seeking
                        if (video.readyState >= 1 && isFinite(video.duration) && video.duration > 0) {
                            // Check if offset exceeds actual video duration (segment mismatch)
                            if (offsetSeconds > video.duration + 1) {
                                // Offset is beyond this video, find the next segment
                                const nextSegment = findNextSegmentForTime(cameraName, timestampMs, segments);
                                if (nextSegment) {
                                    loadSegmentAndSeek(cameraName, video, nextSegment, timestampMs);
                                } else {
                                    console.warn(`  No next segment found, seeking to end of current video`);
                                    video.currentTime = video.duration - 0.1;
                                }
                            } else {
                                // Video metadata is loaded and duration is valid, we can seek
                                const seekTime = Math.max(0, Math.min(offsetSeconds, video.duration));
                                video.currentTime = seekTime;
                            }
                        } else {
                            // Video not ready or duration not available, wait for metadata
                            const metadataHandler = () => {
                                if (isFinite(video.duration) && video.duration > 0) {
                                    // Check if offset exceeds actual video duration
                                    if (offsetSeconds > video.duration + 1) {
                                        const nextSegment = findNextSegmentForTime(cameraName, timestampMs, segments);
                                        if (nextSegment) {
                                            loadSegmentAndSeek(cameraName, video, nextSegment, timestampMs);
                                        }
                                    } else {
                                        const seekTime = Math.max(0, Math.min(offsetSeconds, video.duration));
                                        video.currentTime = seekTime;
                                    }
                                } else {
                                    console.warn(`  Metadata loaded but duration still invalid: ${video.duration}`);
                                }
                            };
                            video.removeEventListener('loadedmetadata', metadataHandler);
                            video.addEventListener('loadedmetadata', metadataHandler, { once: true });
                        }

                        // Auto-start playback after seeking
                        playbackState.playing = true;
                        video.play().catch(err => console.warn(`Failed to start playback for ${cameraName}:`, err));
                        updatePlayPauseButton();
                    } else {
                        // Different segment, need to load it
                        video.src = newSrc;
                        video.playbackRate = playbackState.speed;

                        // Seek to the correct position once metadata is loaded
                        video.onloadedmetadata = () => {
                            if (isFinite(video.duration) && video.duration > 0) {
                                // Check if offset exceeds actual video duration (segment mismatch)
                                if (offsetSeconds > video.duration + 1) {
                                    const nextSegment = findNextSegmentForTime(cameraName, timestampMs, segments);
                                    if (nextSegment && nextSegment !== matchingSegment) {
                                        loadSegmentAndSeek(cameraName, video, nextSegment, timestampMs);
                                        return;
                                    } else {
                                        console.warn(`  No next segment found, playing from start of next segment or end of current`);
                                        video.currentTime = 0; // Start from beginning if we can't find exact position
                                    }
                                } else {
                                    const seekTime = Math.max(0, Math.min(offsetSeconds, video.duration));
                                    video.currentTime = seekTime;
                                }
                            } else {
                                console.warn(`Duration invalid for ${cameraName}: ${video.duration}, seeking to ${offsetSeconds}s anyway`);
                                video.currentTime = offsetSeconds;
                            }

                            // Auto-start playback after loading new segment
                            playbackState.playing = true;
                            video.play().catch(err => console.warn(`Failed to start playback for ${cameraName}:`, err));
                            updatePlayPauseButton();
                        };
                    }
                } else {
                    console.warn(`‚ö†Ô∏è  No segment found for ${cameraName} at timestamp ${timestampMs} (${clickedDate.toLocaleString()})`);
                    console.warn(`  Timeline range: ${startMs} to ${endMs}`);
                    console.warn(`  Clicked is ${timestampMs < startMs ? 'BEFORE' : 'AFTER'} timeline range`);
                }
            });
        }

        // Helper function to find the next segment that contains or follows the timestamp
        function findNextSegmentForTime(cameraName, timestampMs, segments) {
            // Sort segments by start time
            const sortedSegments = [...segments].sort((a, b) => {
                return new Date(a.start_time).getTime() - new Date(b.start_time).getTime();
            });

            // Find the first segment that starts after the target time
            // This handles the case where the target falls in a gap between segments
            let closestAfter = null;
            let closestAfterDist = Infinity;

            for (const seg of sortedSegments) {
                const segStart = new Date(seg.start_time).getTime();
                const segEnd = seg.end_time ? new Date(seg.end_time).getTime() : segStart + 300000;

                // If this segment contains our target time, return it
                if (segStart <= timestampMs && timestampMs < segEnd) {
                    return seg;
                }

                // Track the closest segment that starts after our target
                if (segStart > timestampMs) {
                    const dist = segStart - timestampMs;
                    if (dist < closestAfterDist) {
                        closestAfterDist = dist;
                        closestAfter = seg;
                    }
                }
            }

            // If we found a segment that starts after our target (within 5 minutes), use it
            if (closestAfter && closestAfterDist < 300000) {
                return closestAfter;
            }

            return null;
        }

        // Helper function to load a segment and seek to the correct position
        function loadSegmentAndSeek(cameraName, video, segment, timestampMs) {
            const segmentStart = segment.start_time.replace(' ', 'T');
            const segmentEnd = segment.end_time ? segment.end_time.replace(' ', 'T') : null;
            const segmentStartMs = new Date(segment.start_time).getTime();

            // Calculate offset within this segment
            const offsetSeconds = Math.max(0, (timestampMs - segmentStartMs) / 1000);

            const cacheBuster = Date.now();
            const endParam = segmentEnd ? `&end_time=${encodeURIComponent(segmentEnd)}` : '';
            video.src = `/api/playback/video/${encodeURIComponent(cameraName)}?start_time=${encodeURIComponent(segmentStart)}${endParam}&_=${cacheBuster}`;
            video.playbackRate = playbackState.speed;

            video.onloadedmetadata = () => {
                if (isFinite(video.duration) && video.duration > 0) {
                    const seekTime = Math.max(0, Math.min(offsetSeconds, video.duration));
                    video.currentTime = seekTime;
                }
                // Apply current playback speed
                video.playbackRate = playbackState.speed;
                playbackState.playing = true;
                video.play().catch(err => console.warn(`Failed to start playback:`, err));
                updatePlayPauseButton();
            };
        }

        function updateTimelinePosition(percent) {
            const progress = document.getElementById('timeline-progress');
            const handle = document.getElementById('timeline-handle');
            progress.style.width = percent + '%';
            handle.style.left = percent + '%';
        }

        function showTooltip(event) {
            const tooltip = document.getElementById('timeline-tooltip');
            const slider = document.getElementById('timeline-slider');
            const rect = slider.getBoundingClientRect();
            const padding = 10; // Timeline track has 10px padding on each side

            // Calculate position relative to the actual track (accounting for padding)
            const x = event.clientX - rect.left - padding;
            const trackWidth = rect.width - (padding * 2);
            const percent = Math.max(0, Math.min(100, (x / trackWidth) * 100));

            if (!playbackState.startTime || !playbackState.endTime) return;

            const startMs = new Date(playbackState.startTime).getTime();
            const endMs = new Date(playbackState.endTime).getTime();
            const rangeMs = endMs - startMs;
            const targetTimeMs = startMs + (rangeMs * percent / 100);
            const targetDate = new Date(targetTimeMs);

            // Check if this time has a recording
            let hasRecording = false;
            selectedCameras.forEach(cameraName => {
                const segments = currentRecordings[cameraName] || [];
                segments.forEach(seg => {
                    const segStart = new Date(seg.start_time).getTime();
                    const segEnd = new Date(seg.end_time).getTime();
                    if (targetTimeMs >= segStart && targetTimeMs < segEnd) {
                        hasRecording = true;
                    }
                });
            });

            // Format as "6:32:51 PM" with date if different from start
            const startDate = new Date(playbackState.startTime);
            const timeStr = targetDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // Build tooltip text
            let tooltipText;
            if (targetDate.toDateString() !== startDate.toDateString()) {
                tooltipText = targetDate.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + timeStr;
            } else {
                tooltipText = timeStr;
            }

            // Add indicator if no recording at this time
            if (!hasRecording) {
                tooltipText += ' (no recording)';
                tooltip.style.color = '#ff6b6b';
            } else {
                tooltip.style.color = '#fff';
            }

            tooltip.textContent = tooltipText;
            tooltip.style.left = percent + '%';
            tooltip.style.display = 'block';
        }

        function hideTooltip() {
            if (!playbackState.isDragging) {
                document.getElementById('timeline-tooltip').style.display = 'none';
            }
        }

        // Mouse up anywhere stops dragging
        document.addEventListener('mouseup', () => {
            playbackState.isDragging = false;
            hideTooltip();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Handle ESC to close modals
            if (e.key === 'Escape') {
                hideExportPanel();
                hideShortcuts();
                return;
            }

            // Handle ? to show shortcuts
            if (e.key === '?') {
                e.preventDefault();
                showShortcuts();
                return;
            }

            // Handle 'a' to toggle AI detections
            if (e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                const checkbox = document.getElementById('show-ai-detections');
                checkbox.checked = !checkbox.checked;
                toggleAIDetections();
                return;
            }

            // Ignore if typing in input fields
            if (e.target.tagName === 'INPUT') return;

            switch(e.key) {
                case ' ':  // Spacebar - play/pause
                case 'k':  // k - play/pause (YouTube style)
                    e.preventDefault();
                    togglePlayPause();
                    break;

                case 'ArrowLeft':  // Left arrow - rewind 5 seconds
                    e.preventDefault();
                    skipTime(-5);
                    break;

                case 'ArrowRight':  // Right arrow - forward 5 seconds
                    e.preventDefault();
                    skipTime(5);
                    break;

                case 'j':  // j - rewind 10 seconds
                    e.preventDefault();
                    skipTime(-10);
                    break;

                case 'l':  // l - forward 10 seconds
                    e.preventDefault();
                    skipTime(10);
                    break;

                case '0':  // 0 - jump to start
                    e.preventDefault();
                    jumpToPercent(0);
                    break;

                case '1': case '2': case '3': case '4': case '5':
                case '6': case '7': case '8': case '9':
                    e.preventDefault();
                    jumpToPercent(parseInt(e.key) * 10);
                    break;

                case '<':  // < - slow down
                case ',':
                    e.preventDefault();
                    changeSpeed(-0.25);
                    break;

                case '>':  // > - speed up
                case '.':
                    e.preventDefault();
                    changeSpeed(0.25);
                    break;

                case 'f':  // f - fullscreen (first camera)
                case 'F':
                    e.preventDefault();
                    const firstCamera = selectedCameras.values().next().value;
                    if (firstCamera) {
                        enterFullscreenPlayback(firstCamera);
                    }
                    break;
            }
        });

        function skipTime(seconds) {
            Object.values(videoElements).forEach(video => {
                video.currentTime = Math.max(0, Math.min(video.duration || 0, video.currentTime + seconds));
            });
        }

        function jumpToPercent(percent) {
            Object.values(videoElements).forEach(video => {
                const duration = video.duration || 0;
                video.currentTime = (duration * percent) / 100;
            });
            updateTimelinePosition(percent);
        }

        function changeSpeed(delta) {
            const newSpeed = Math.max(0.25, Math.min(8, playbackState.speed + delta));
            const speedButtons = [0.5, 1.0, 1.5, 2.0];
            const closest = speedButtons.reduce((prev, curr) =>
                Math.abs(curr - newSpeed) < Math.abs(prev - newSpeed) ? curr : prev
            );

            // Find and click the closest speed button
            document.querySelectorAll('.speed-btn').forEach(btn => {
                if (btn.textContent.includes(closest.toString())) {
                    btn.click();
                }
            });
        }

        function enterFullscreenPlayback(cameraName) {
            const video = videoElements[cameraName];
            if (!video) {
                console.error(`Video element not found for camera: ${cameraName}`);
                return;
            }

            // Use the video-player container for fullscreen so overlays are visible
            const player = video.closest('.video-player');
            const elementToFullscreen = player || video;

            // Use the fullscreen API
            if (elementToFullscreen.requestFullscreen) {
                elementToFullscreen.requestFullscreen();
            } else if (elementToFullscreen.webkitRequestFullscreen) {
                elementToFullscreen.webkitRequestFullscreen();
            } else if (elementToFullscreen.mozRequestFullScreen) {
                elementToFullscreen.mozRequestFullScreen();
            } else if (elementToFullscreen.msRequestFullscreen) {
                elementToFullscreen.msRequestFullscreen();
            } else {
                showNotification('Fullscreen not supported by your browser', 'warning');
            }
        }

        function showExportPanel() {
            const date = document.getElementById('playback-date').value;
            const startTime = document.getElementById('start-time').value;
            const endTime = document.getElementById('end-time').value;

            if (!date || !startTime || !endTime) {
                showNotification('Please select date and time range first', 'warning');
                return;
            }

            document.getElementById('export-date').textContent = date;
            document.getElementById('export-time-range').textContent = `${startTime} - ${endTime}`;
            document.getElementById('export-cameras').textContent = Array.from(selectedCameras).join(', ');

            document.getElementById('export-overlay').classList.add('active');
            document.getElementById('export-panel').classList.add('active');
        }

        function hideExportPanel() {
            document.getElementById('export-overlay').classList.remove('active');
            document.getElementById('export-panel').classList.remove('active');
        }

        function showShortcuts() {
            document.getElementById('export-overlay').classList.add('active');
            document.getElementById('shortcuts-modal').classList.add('active');
        }

        function hideShortcuts() {
            document.getElementById('export-overlay').classList.remove('active');
            document.getElementById('shortcuts-modal').classList.remove('active');
        }

        function toggleAIToggle() {
            const checkbox = document.getElementById('show-ai-detections');
            checkbox.checked = !checkbox.checked;
            toggleAIDetections();
        }

        function toggleAIDetections() {
            const checkbox = document.getElementById('show-ai-detections');
            const toggleSwitch = document.getElementById('ai-toggle-switch');
            const personLegend = document.getElementById('person-legend');
            const vehicleLegend = document.getElementById('vehicle-legend');

            playbackState.showAIDetections = checkbox.checked;

            // Update toggle switch visual state
            if (checkbox.checked) {
                toggleSwitch.classList.add('active');
                personLegend.style.opacity = '1';
                vehicleLegend.style.opacity = '1';
            } else {
                toggleSwitch.classList.remove('active');
                personLegend.style.opacity = '0.3';
                vehicleLegend.style.opacity = '0.3';
            }

            // Refresh timeline markers
            updateTimeline();
        }

        async function performExport() {
            const date = document.getElementById('playback-date').value;
            const startTime = document.getElementById('start-time').value;
            const endTime = document.getElementById('end-time').value;

            const startDateTime = `${date}T${startTime}`;
            const endDateTime = `${date}T${endTime}`;

            // Export each camera
            for (const cameraName of selectedCameras) {
                const url = `/api/playback/video/${encodeURIComponent(cameraName)}?start_time=${encodeURIComponent(startDateTime)}&end_time=${encodeURIComponent(endDateTime)}`;

                // Create download link
                const a = document.createElement('a');
                a.href = url;
                a.download = `${cameraName}_${date}_${startTime.replace(/:/g, '')}-${endTime.replace(/:/g, '')}.mp4`;
                a.click();
            }

            hideExportPanel();
            showNotification('Download started. Files will be saved to your Downloads folder.', 'success', 5000);
        }

        // Zoom functionality for playback videos
        function zoomVideo(cameraName, action, box) {
            const video = document.getElementById(`video-${cameraName}`);
            const player = video.parentElement;
            const indicator = document.getElementById(`zoom-indicator-${cameraName}`);

            let scale = parseFloat(player.dataset.zoomScale) || 1;
            let x = parseFloat(player.dataset.zoomX) || 0;
            let y = parseFloat(player.dataset.zoomY) || 0;

            if (action === 'in') {
                scale = Math.min(scale * 1.25, 10); // Max 10x zoom
            } else if (action === 'out') {
                scale = Math.max(scale / 1.25, 0.5); // Min 0.5x zoom
                if (scale <= 1) {
                    scale = 1;
                    x = 0;
                    y = 0;
                }
            } else if (action === 'reset') {
                scale = 1;
                x = 0;
                y = 0;
            } else if (action === 'selection' && box) {
                // Zoom to selected rectangular area (supports progressive zoom)
                const playerRect = player.getBoundingClientRect();

                // Get the natural video dimensions
                const naturalWidth = video.videoWidth || video.width;
                const naturalHeight = video.videoHeight || video.height;

                // Calculate how the video is displayed at 100% zoom (object-fit: contain)
                const playerAspect = playerRect.width / playerRect.height;
                const videoAspect = naturalWidth / naturalHeight;

                let baseDisplayWidth, baseDisplayHeight;

                if (videoAspect > playerAspect) {
                    // Video is wider - fit to width
                    baseDisplayWidth = playerRect.width;
                    baseDisplayHeight = playerRect.width / videoAspect;
                } else {
                    // Video is taller - fit to height
                    baseDisplayHeight = playerRect.height;
                    baseDisplayWidth = playerRect.height * videoAspect;
                }

                // Convert selection box center from screen coords to wrapper coords
                const wrapperCenterX = playerRect.width / 2;
                const wrapperCenterY = playerRect.height / 2;

                // Selection box center in wrapper coords
                const selBoxCenterX = (box.x - playerRect.left) + box.width / 2;
                const selBoxCenterY = (box.y - playerRect.top) + box.height / 2;

                // Offset from wrapper center
                const offsetFromCenterX = selBoxCenterX - wrapperCenterX;
                const offsetFromCenterY = selBoxCenterY - wrapperCenterY;

                // Reverse current transform to get unzoomed position
                // CSS applies: scale(s) translate(tx, ty) which becomes: screenPos = s * (displayPos + t)
                // To reverse: displayPos = (screenPos / s) - t
                const unzoomedX = (offsetFromCenterX / scale) - x;
                const unzoomedY = (offsetFromCenterY / scale) - y;

                // Convert to normalized coordinates (0-1, with 0.5 being center)
                const normX = 0.5 + (unzoomedX / baseDisplayWidth);
                const normY = 0.5 + (unzoomedY / baseDisplayHeight);

                // Calculate new zoom scale to fit selection to 90% of viewport
                const scaleX = (playerRect.width * 0.9) / box.width;
                const scaleY = (playerRect.height * 0.9) / box.height;
                const targetScale = Math.min(scaleX, scaleY, 10);
                const newScale = targetScale * scale; // Progressive zoom - multiply by current scale

                // Calculate translation to center this point
                const displayPosX = (normX - 0.5) * baseDisplayWidth;
                const displayPosY = (normY - 0.5) * baseDisplayHeight;

                x = -displayPosX;
                y = -displayPosY;
                scale = newScale;
            }

            player.dataset.zoomScale = scale;
            player.dataset.zoomX = x;
            player.dataset.zoomY = y;

            video.style.transform = `scale(${scale}) translate(${x}px, ${y}px)`;
            indicator.textContent = `${Math.round(scale * 100)}%`;

            if (scale > 1) {
                player.classList.add('zoomed');
            } else {
                player.classList.remove('zoomed');
            }
        }

        // Mouse wheel zoom for playback videos
        document.addEventListener('wheel', (e) => {
            const player = e.target.closest('.video-player');
            if (!player) return;

            const video = player.querySelector('video');
            if (!video) return;

            const cameraName = video.id.replace('video-', '');
            e.preventDefault();

            const delta = e.deltaY > 0 ? -1 : 1;
            if (delta > 0) {
                zoomVideo(cameraName, 'in');
            } else {
                zoomVideo(cameraName, 'out');
            }
        }, { passive: false });

        // Drag-to-select zoom functionality for playback videos
        // Updated: 2026-01-19 14:05 - Fixed progressive zoom and mouse bounds check
        let panState = {
            isPanning: false,
            isSelecting: false,
            selectionModeEnabled: {},  // Per-camera selection mode tracking
            cameraName: null,
            startX: 0,
            startY: 0,
            selectionStartX: 0,
            selectionStartY: 0
        };

        // Toggle selection mode for playback video
        function togglePlaybackSelection(cameraName) {
            const btn = document.querySelector(`.select-area-btn[data-camera="${cameraName}"]`);
            const player = document.getElementById(`video-${cameraName}`).parentElement;

            panState.selectionModeEnabled[cameraName] = !panState.selectionModeEnabled[cameraName];

            if (panState.selectionModeEnabled[cameraName]) {
                btn.classList.add('active');
                player.classList.add('selecting');
            } else {
                btn.classList.remove('active');
                player.classList.remove('selecting');
            }
        }

        // Setup click handlers for select-area buttons
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('select-area-btn')) {
                const cameraName = e.target.dataset.camera;
                togglePlaybackSelection(cameraName);
            }
        });

        document.addEventListener('mousedown', (e) => {
            const player = e.target.closest('.video-player');
            if (!player) return;

            // Don't trigger on zoom buttons
            if (e.target.closest('.zoom-btn')) return;

            const video = player.querySelector('video');
            if (!video) return;

            const playerRect = player.getBoundingClientRect();

            // Check if click is within player bounds (don't check video bounds when zoomed)
            if (e.clientX < playerRect.left || e.clientX > playerRect.right ||
                e.clientY < playerRect.top || e.clientY > playerRect.bottom) {
                return;
            }

            const cameraName = video.id.replace('video-', '');
            const scale = parseFloat(player.dataset.zoomScale) || 1;

            if (panState.selectionModeEnabled[cameraName]) {
                // Selection mode is enabled - start drawing selection box
                panState.isSelecting = true;
                panState.cameraName = cameraName;
                panState.selectionStartX = e.clientX;
                panState.selectionStartY = e.clientY;

                // Initialize selection box
                const selectionBox = document.getElementById(`zoom-selection-${cameraName}`);
                selectionBox.style.left = (e.clientX - playerRect.left) + 'px';
                selectionBox.style.top = (e.clientY - playerRect.top) + 'px';
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
                selectionBox.classList.add('active');
            } else if (scale > 1) {
                // Not in selection mode and already zoomed - enable panning
                panState.isPanning = true;
                panState.cameraName = cameraName;
                panState.startX = e.clientX - (parseFloat(player.dataset.zoomX) || 0);
                panState.startY = e.clientY - (parseFloat(player.dataset.zoomY) || 0);
                player.classList.add('panning');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (panState.isPanning) {
                // Pan the zoomed video
                const video = document.getElementById(`video-${panState.cameraName}`);
                if (!video) return;

                const player = video.parentElement;
                const x = e.clientX - panState.startX;
                const y = e.clientY - panState.startY;

                player.dataset.zoomX = x;
                player.dataset.zoomY = y;

                const scale = parseFloat(player.dataset.zoomScale) || 1;
                video.style.transform = `scale(${scale}) translate(${x}px, ${y}px)`;
            } else if (panState.isSelecting) {
                // Update selection box
                const video = document.getElementById(`video-${panState.cameraName}`);
                if (!video) return;

                const player = video.parentElement;
                const playerRect = player.getBoundingClientRect();
                const selectionBox = document.getElementById(`zoom-selection-${panState.cameraName}`);

                const x = Math.min(e.clientX, panState.selectionStartX) - playerRect.left;
                const y = Math.min(e.clientY, panState.selectionStartY) - playerRect.top;
                const width = Math.abs(e.clientX - panState.selectionStartX);
                const height = Math.abs(e.clientY - panState.selectionStartY);

                selectionBox.style.left = x + 'px';
                selectionBox.style.top = y + 'px';
                selectionBox.style.width = width + 'px';
                selectionBox.style.height = height + 'px';
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (panState.isPanning) {
                const video = document.getElementById(`video-${panState.cameraName}`);
                if (video) {
                    video.parentElement.classList.remove('panning');
                }
                panState.isPanning = false;
                panState.cameraName = null;
            } else if (panState.isSelecting) {
                const video = document.getElementById(`video-${panState.cameraName}`);
                if (video) {
                    const player = video.parentElement;
                    const selectionBox = document.getElementById(`zoom-selection-${panState.cameraName}`);

                    selectionBox.classList.remove('active');

                    // Calculate final selection box
                    const x = Math.min(e.clientX, panState.selectionStartX);
                    const y = Math.min(e.clientY, panState.selectionStartY);
                    const width = Math.abs(e.clientX - panState.selectionStartX);
                    const height = Math.abs(e.clientY - panState.selectionStartY);

                    // Only zoom if selection box is large enough (minimum 20px)
                    if (width > 20 && height > 20) {
                        zoomVideo(panState.cameraName, 'selection', { x, y, width, height });
                        // Keep selection mode enabled for multiple zooms
                    }
                }
                panState.isSelecting = false;
                panState.cameraName = null;
            }
        });

        // Double-click to reset zoom on playback videos
        document.addEventListener('dblclick', (e) => {
            const player = e.target.closest('.video-player');
            if (!player) return;

            const video = player.querySelector('video');
            if (!video) return;

            const cameraName = video.id.replace('video-', '');
            zoomVideo(cameraName, 'reset');
        });

        // Initialize on load
        init();

        // Update timeline and current time display
        setInterval(() => {
            if (Object.keys(videoElements).length === 0) return;

            // Get first video's current time as reference
            const firstVideo = Object.values(videoElements)[0];
            if (firstVideo && !playbackState.isDragging) {
                const duration = firstVideo.duration || 0;
                const videoCurrentTime = firstVideo.currentTime || 0;

                // Update progress bar - calculate position within ENTIRE TIMELINE RANGE
                if (duration > 0 && playbackState.startTime && playbackState.endTime) {
                    // Get the segment's start time from the video source URL
                    const videoSrc = firstVideo.src;
                    const startTimeMatch = videoSrc.match(/start_time=([^&]+)/);

                    if (startTimeMatch) {
                        const segmentStartTime = decodeURIComponent(startTimeMatch[1]);
                        const segmentStartMs = new Date(segmentStartTime).getTime();

                        // Calculate actual timestamp = segment start + video current time
                        const currentTimestampMs = segmentStartMs + (videoCurrentTime * 1000);

                        // Calculate percentage within timeline range
                        const startMs = new Date(playbackState.startTime).getTime();
                        const endMs = new Date(playbackState.endTime).getTime();
                        const rangeMs = endMs - startMs;

                        if (rangeMs > 0) {
                            const percent = ((currentTimestampMs - startMs) / rangeMs) * 100;
                            updateTimelinePosition(percent);

                            // Update playbackState.currentTime as offset from timeline start
                            playbackState.currentTime = (currentTimestampMs - startMs) / 1000;

                            // Update timestamp display (actual recording time)
                            const currentDate = new Date(currentTimestampMs);
                            document.getElementById('timestamp-display').textContent =
                                currentDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', second: '2-digit', hour12: true });

                            // Update elapsed time display (time since start of selected range)
                            const elapsedSeconds = (currentTimestampMs - startMs) / 1000;
                            document.getElementById('current-time-display').textContent = formatDuration(elapsedSeconds);
                        }
                    }
                } else {
                    // Fallback: show segment position if timeline range not available
                    document.getElementById('current-time-display').textContent = formatDuration(videoCurrentTime);
                }

                // Auto-pause at end of segment
                if (videoCurrentTime >= duration && playbackState.playing) {
                    togglePlayPause();
                }
            }
        }, 100);

        // ===== Keyboard Shortcuts =====
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                return;
            }

            // Prevent default for keys we handle
            const handledKeys = ['Space', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'KeyF', 'KeyM'];
            if (handledKeys.includes(e.code)) {
                e.preventDefault();
            }

            switch(e.code) {
                case 'Space':
                case 'KeyK':
                    // Space or K: Play/Pause
                    togglePlayPause();
                    break;

                case 'ArrowLeft':
                    // Left arrow: Rewind 5 seconds
                    skipTime(-5);
                    break;

                case 'ArrowRight':
                    // Right arrow: Skip forward 5 seconds
                    skipTime(5);
                    break;

                case 'KeyJ':
                    // J: Rewind 10 seconds
                    skipTime(-10);
                    break;

                case 'KeyL':
                    // L: Skip forward 10 seconds
                    skipTime(10);
                    break;

                case 'ArrowUp':
                    // Up arrow: Increase playback speed
                    changePlaybackSpeed(0.25);
                    break;

                case 'ArrowDown':
                    // Down arrow: Decrease playback speed
                    changePlaybackSpeed(-0.25);
                    break;

                case 'Digit0':
                case 'Digit1':
                case 'Digit2':
                case 'Digit3':
                case 'Digit4':
                case 'Digit5':
                case 'Digit6':
                case 'Digit7':
                case 'Digit8':
                case 'Digit9':
                    // Number keys: Jump to percentage (0 = start, 9 = 90%, etc.)
                    const percentage = parseInt(e.code.replace('Digit', '')) * 10;
                    jumpToPercentage(percentage);
                    break;

                case 'KeyF':
                    // F: Toggle fullscreen
                    toggleFullscreen();
                    break;

                case 'KeyM':
                    // M: Mute/Unmute
                    toggleMute();
                    break;

                case 'Comma':
                    // , (comma): Previous frame (when paused)
                    if (!playbackState.playing) {
                        skipTime(-0.033); // ~1 frame at 30fps
                    }
                    break;

                case 'Period':
                    // . (period): Next frame (when paused)
                    if (!playbackState.playing) {
                        skipTime(0.033); // ~1 frame at 30fps
                    }
                    break;
            }
        });

        function skipTime(seconds) {
            const firstVideo = Object.values(videoElements)[0];
            if (!firstVideo) return;

            const currentTime = firstVideo.currentTime;
            const duration = firstVideo.duration;
            const newTime = Math.max(0, Math.min(currentTime + seconds, duration));

            // Calculate the timestamp in the overall timeline
            const startMs = new Date(playbackState.startTime).getTime();
            const offsetMs = newTime * 1000;
            const targetMs = startMs + offsetMs;

            seekToTime(targetMs);
        }

        function jumpToPercentage(percentage) {
            if (!playbackState.startTime || !playbackState.endTime) return;

            const startMs = new Date(playbackState.startTime).getTime();
            const endMs = new Date(playbackState.endTime).getTime();
            const rangeMs = endMs - startMs;
            const targetMs = startMs + (rangeMs * percentage / 100);

            seekToTime(targetMs);
        }

        function changePlaybackSpeed(delta) {
            const firstVideo = Object.values(videoElements)[0];
            if (!firstVideo) return;

            const currentSpeed = firstVideo.playbackRate || 1.0;
            const newSpeed = Math.max(0.25, Math.min(currentSpeed + delta, 4.0));

            // Update all videos
            Object.values(videoElements).forEach(video => {
                video.playbackRate = newSpeed;
            });

            // Update playback state
            playbackState.speed = newSpeed;

            // Update UI buttons (highlight closest speed button)
            updateSpeedButtons(newSpeed);

            // Show speed indicator
            showNotification(`Playback Speed: ${newSpeed.toFixed(2)}x`);
        }

        function updateSpeedButtons(currentSpeed) {
            const speedButtons = document.querySelectorAll('.speed-btn');
            const speeds = [0.5, 1.0, 1.5, 2.0, 4.0, 8.0];

            // Find closest predefined speed
            let closestSpeed = speeds[0];
            let minDiff = Math.abs(currentSpeed - speeds[0]);

            speeds.forEach(speed => {
                const diff = Math.abs(currentSpeed - speed);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestSpeed = speed;
                }
            });

            // Update button states
            speedButtons.forEach(btn => {
                btn.classList.remove('active');
                const btnSpeed = parseFloat(btn.textContent);
                if (Math.abs(btnSpeed - closestSpeed) < 0.01) {
                    btn.classList.add('active');
                }
            });
        }

        function toggleFullscreen() {
            const videoGrid = document.getElementById('video-grid');
            if (!document.fullscreenElement) {
                videoGrid.requestFullscreen().catch(err => {
                    console.error('Error entering fullscreen:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }

        function toggleMute() {
            Object.values(videoElements).forEach(video => {
                video.muted = !video.muted;
            });

            const firstVideo = Object.values(videoElements)[0];
            if (firstVideo) {
                showNotification(firstVideo.muted ? 'Muted' : 'Unmuted');
            }
        }

        function showNotification(message) {
            // Remove existing notification
            const existing = document.getElementById('keyboard-notification');
            if (existing) {
                existing.remove();
            }

            // Create notification
            const notification = document.createElement('div');
            notification.id = 'keyboard-notification';
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px 40px;
                border-radius: 8px;
                font-size: 24px;
                font-weight: bold;
                z-index: 10000;
                pointer-events: none;
            `;
            document.body.appendChild(notification);

            // Remove after 1 second
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.3s';
                setTimeout(() => notification.remove(), 300);
            }, 700);
        }

        // Timeline Selector Integration
        let timelineSelector = null;

        function toggleTimelineSelector() {
            const panel = document.getElementById('timeline-selector-panel');
            const controlsPanel = document.getElementById('controls-panel');
            const videoGrid = document.querySelector('.video-grid');
            const timelinePanel = document.querySelector('.timeline-panel');
            const btn = document.getElementById('timeline-selector-btn');

            if (panel.style.display === 'none') {
                // Show timeline selector
                panel.style.display = 'block';
                controlsPanel.style.display = 'none';
                videoGrid.style.display = 'none';
                timelinePanel.style.display = 'none';
                btn.style.background = '#3a8eef';
                btn.textContent = '‚úï Close';

                // Initialize timeline selector if not already created
                if (!timelineSelector) {
                    initTimelineSelector();
                } else {
                    // Refresh with current settings
                    timelineSelector.refresh();
                }
            } else {
                // Hide timeline selector
                panel.style.display = 'none';
                controlsPanel.style.display = 'flex';
                videoGrid.style.display = 'grid';
                timelinePanel.style.display = 'block';
                btn.style.background = '#4a9eff';
                btn.textContent = 'üìä Timeline';
            }
        }

        function initTimelineSelector() {
            const date = document.getElementById('playback-date').value;
            const cameras = Array.from(selectedCameras);

            if (cameras.length === 0) {
                showNotification('Please select at least one camera', 'warning');
                toggleTimelineSelector(); // Close the panel
                return;
            }

            timelineSelector = new TimelineSelector('timeline-selector-container', {
                date: date ? new Date(date + 'T00:00:00') : new Date(),
                cameras: cameras,
                height: 180,
                onRangeSelected: (range) => {
                    applyTimelineSelection(range);
                }
            });
        }

        function applyTimelineSelection(range) {
            // Convert selected times to input values
            const dateStr = range.startTime.toISOString().split('T')[0];
            const startTimeStr = range.startTime.toTimeString().substring(0, 5);
            const endTimeStr = range.endTime.toTimeString().substring(0, 5);

            // Set the form values
            document.getElementById('playback-date').value = dateStr;
            document.getElementById('start-time').value = startTimeStr;
            document.getElementById('end-time').value = endTimeStr;

            // Enforce future limits (in case timeline allowed selecting future times)
            enforceFutureLimits();

            // Close timeline selector and show playback
            toggleTimelineSelector();

            // Load the recordings
            showNotification('Loading selected time range...', 'info');
            setTimeout(() => {
                loadRecordings();
            }, 100);
        }

        // Update timeline selector when cameras change
        const originalToggleCamera = toggleCamera;
        window.toggleCamera = function(cameraName, enabled) {
            originalToggleCamera(cameraName, enabled);

            // Update timeline selector if it's open
            if (timelineSelector && document.getElementById('timeline-selector-panel').style.display !== 'none') {
                timelineSelector.setCameras(Array.from(selectedCameras));
            }
        };

        // Show keyboard shortcuts help on ? key
        document.addEventListener('keydown', (e) => {
            if (e.key === '?' || (e.shiftKey && e.key === '/')) {
                e.preventDefault();
                showKeyboardShortcuts();
            }
        });

        function showKeyboardShortcuts() {
            const shortcuts = `
                <div style="max-width: 500px; margin: 0 auto;">
                    <h3 style="margin-top: 0;">Keyboard Shortcuts</h3>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px 20px; font-size: 14px;">
                        <strong>Space / K</strong><span>Play/Pause</span>
                        <strong>‚Üê / ‚Üí</strong><span>Rewind/Forward 5s</span>
                        <strong>J / L</strong><span>Rewind/Forward 10s</span>
                        <strong>‚Üë / ‚Üì</strong><span>Increase/Decrease speed</span>
                        <strong>0-9</strong><span>Jump to 0%-90%</span>
                        <strong>, / .</strong><span>Previous/Next frame (paused)</span>
                        <strong>F</strong><span>Fullscreen</span>
                        <strong>M</strong><span>Mute/Unmute</span>
                        <strong>?</strong><span>Show this help</span>
                    </div>
                </div>
            `;

            showNotification('Press ? for keyboard shortcuts');
        }
    </script>
</body>
</html>
