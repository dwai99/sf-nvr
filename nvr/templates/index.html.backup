<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SF-NVR - Recording</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .header {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 { color: #4a9eff; }

        .stats {
            display: flex;
            gap: 20px;
        }

        .stat {
            background: #333;
            padding: 10px 20px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-label { color: #888; font-size: 0.9em; }
        .stat-value { color: #4a9eff; font-size: 1.5em; font-weight: bold; }

        .camera-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
        }

        .camera-card {
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .camera-header {
            background: #333;
            padding: 15px;
            border-bottom: 2px solid #4aff4a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .camera-name-display {
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            flex: 1;
        }

        .camera-name-display:hover {
            color: #4a9eff;
        }

        .camera-name-input {
            font-size: 1.1em;
            font-weight: bold;
            background: #444;
            border: 2px solid #4a9eff;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            flex: 1;
            margin-right: 8px;
        }

        .rename-actions {
            display: none;
            gap: 4px;
        }

        .rename-actions.active {
            display: flex;
        }

        .rename-btn {
            background: #4a9eff;
            border: none;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background 0.2s;
        }

        .rename-btn:hover {
            background: #3a8eef;
        }

        .rename-btn.cancel {
            background: #666;
        }

        .rename-btn.cancel:hover {
            background: #777;
        }

        .reconnect-btn {
            background: transparent;
            border: 1px solid #666;
            color: #aaa;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
            margin-left: auto;
            margin-right: 8px;
        }

        .reconnect-btn:hover {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
            transform: rotate(180deg);
        }

        .reconnect-btn:active {
            transform: rotate(360deg);
        }

        .status-recording {
            background: #4aff4a;
            color: #000;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .rec-dot {
            width: 8px;
            height: 8px;
            background: #f00;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .camera-video {
            width: 100%;
            height: 300px;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }

        .camera-video:hover::after {
            content: 'â›¶ Fullscreen';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(74, 158, 255, 0.9);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            z-index: 10;
        }

        .camera-video img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .camera-info {
            padding: 15px;
            font-size: 0.9em;
            color: #888;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .hidden { display: none; }

        .motion-toggle {
            background: #333;
            border: 1px solid #444;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .motion-toggle:hover {
            background: #444;
            border-color: #4a9eff;
        }

        .motion-toggle.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
        }

        .controls-bar {
            background: #2a2a2a;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-btn {
            background: #4a9eff;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
        }

        .control-btn:hover {
            background: #3a8eef;
        }

        .control-btn.secondary {
            background: #666;
        }

        .control-btn.secondary:hover {
            background: #777;
        }

        .quality-selector {
            display: flex;
            gap: 5px;
            background: #333;
            padding: 5px;
            border-radius: 4px;
        }

        .quality-btn {
            background: #444;
            border: none;
            color: #aaa;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .quality-btn:hover {
            background: #555;
        }

        .quality-btn.active {
            background: #4a9eff;
            color: white;
        }

        .motion-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 74, 74, 0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9em;
            display: none;
            z-index: 5;
        }

        .motion-indicator.active {
            display: block;
            animation: flash 1s infinite;
        }

        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <h1>ðŸŽ¥ SF-NVR</h1>
            <p style="color: #888;">All cameras recording automatically</p>
        </div>
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Cameras</div>
                <div class="stat-value" id="camera-count">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Recording</div>
                <div class="stat-value" id="recording-count">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">CPU</div>
                <div class="stat-value" id="cpu-usage">--%</div>
            </div>
            <div class="stat">
                <div class="stat-label">Memory</div>
                <div class="stat-value" id="memory-usage">--%</div>
            </div>
            <div class="stat">
                <div class="stat-label">Disk</div>
                <div class="stat-value" id="disk-usage">--%</div>
            </div>
            <div class="stat" style="cursor: pointer;" onclick="window.location.href='/playback'">
                <div class="stat-label">ðŸ“¼ Playback</div>
                <div class="stat-value" style="font-size: 0.9em;">Archive</div>
            </div>
        </div>
    </div>

    <div class="controls-bar">
        <span style="color: #aaa; font-size: 0.9em;">Live View Controls:</span>
        <button class="control-btn secondary" id="streaming-mode-btn" onclick="toggleStreamingMode()">
            <span id="streaming-mode-text">ðŸ“¡ MJPEG (Compatible)</span>
        </button>
        <button class="control-btn secondary" id="motion-overlay-btn" onclick="toggleMotionOverlay()">
            <span id="motion-btn-text">âœ— Motion Overlay</span>
        </button>
        <div class="quality-selector" id="quality-selector">
            <button class="quality-btn active" onclick="setQuality('low')">Low (Smooth)</button>
            <button class="quality-btn" onclick="setQuality('medium')">Medium</button>
            <button class="quality-btn" onclick="setQuality('high')">High (Clear)</button>
        </div>
        <span style="color: #666; font-size: 0.85em; margin-left: auto;" id="quality-hint">Low quality = fast grid view</span>
    </div>

    <div class="camera-grid" id="camera-grid"></div>

    <script src="/static/webrtc-client.js"></script>
    <script>
        let cameras = [];
        let showMotionOverlay = false; // Start with overlay off for cleaner video
        let streamQuality = 'low'; // Default to low quality for grid view performance
        let streamingMode = 'mjpeg'; // Start with MJPEG for reliability (can switch to 'direct' for ultra-fast)
        let webrtcPlayers = {}; // Store WebRTC player instances

        function toggleStreamingMode() {
            // Cycle through modes: mjpeg -> direct -> webrtc -> mjpeg
            if (streamingMode === 'mjpeg') {
                streamingMode = 'direct';
            } else if (streamingMode === 'direct') {
                streamingMode = 'webrtc';
            } else {
                streamingMode = 'mjpeg';
            }

            const btn = document.getElementById('streaming-mode-btn');
            const btnText = document.getElementById('streaming-mode-text');
            const qualitySelector = document.getElementById('quality-selector');
            const hint = document.getElementById('quality-hint');

            if (streamingMode === 'direct') {
                btnText.textContent = 'âš¡ DIRECT (Ultra-Fast)';
                btn.classList.remove('secondary');
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                qualitySelector.style.opacity = '0.5';
                qualitySelector.style.pointerEvents = 'none';
                hint.textContent = 'Direct mode: 50-100ms latency';
            } else if (streamingMode === 'webrtc') {
                btnText.textContent = 'ðŸš€ WebRTC (Real-time)';
                btn.classList.remove('secondary');
                btn.style.background = '';
                qualitySelector.style.opacity = '0.5';
                qualitySelector.style.pointerEvents = 'none';
                hint.textContent = 'WebRTC mode: Low latency streaming';
            } else {
                btnText.textContent = 'ðŸ“¡ MJPEG (Compatible)';
                btn.classList.add('secondary');
                btn.style.background = '';
                qualitySelector.style.opacity = '1';
                qualitySelector.style.pointerEvents = 'auto';
                hint.textContent = 'Lower quality = smoother video';
            }

            // Stop all WebRTC players
            Object.values(webrtcPlayers).forEach(player => player.stop());
            webrtcPlayers = {};

            // Rebuild UI with new mode
            updateUI();
        }

        function toggleMotionOverlay() {
            showMotionOverlay = !showMotionOverlay;
            const btn = document.getElementById('motion-overlay-btn');
            const btnText = document.getElementById('motion-btn-text');

            if (showMotionOverlay) {
                btn.classList.remove('secondary');
                btnText.textContent = 'âœ“ Motion Overlay';
            } else {
                btn.classList.add('secondary');
                btnText.textContent = 'âœ— Motion Overlay';
            }

            // Rebuild to update stream URLs
            updateUI();
        }

        function setQuality(quality) {
            if (streamingMode === 'webrtc') return; // Quality doesn't apply to WebRTC

            streamQuality = quality;

            // Update active button
            document.querySelectorAll('.quality-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Rebuild to update stream URLs
            updateUI();
        }

        function buildStreamUrl(cameraName) {
            // Build URL with quality and motion overlay parameters
            let url = `/api/cameras/${encodeURIComponent(cameraName)}/live`;
            const params = [];

            if (!showMotionOverlay) {
                params.push('raw=true');
            }

            // Quality parameter (affects JPEG quality on backend)
            if (streamQuality === 'low') {
                params.push('quality=40');  // Low for maximum smoothness
            } else if (streamQuality === 'medium') {
                params.push('quality=65');  // Medium for balanced performance
            } else if (streamQuality === 'high') {
                params.push('quality=90');  // High for maximum clarity
            }

            if (params.length > 0) {
                url += '?' + params.join('&');
            }

            return url;
        }

        async function fetchCameras() {
            try {
                const response = await fetch('/api/cameras');
                cameras = await response.json();
                updateUI();
            } catch (error) {
                console.error('Error fetching cameras:', error);
            }
        }

        function updateUI() {
            const grid = document.getElementById('camera-grid');

            document.getElementById('camera-count').textContent = cameras.length;
            document.getElementById('recording-count').textContent =
                cameras.filter(c => c.recording).length;

            // Use DocumentFragment for faster DOM updates
            const fragment = document.createDocumentFragment();
            cameras.forEach(camera => {
                const card = createCameraCard(camera);
                fragment.appendChild(card);
            });

            // Single DOM update (much faster than appendChild in loop)
            grid.innerHTML = '';
            grid.appendChild(fragment);

            // Initialize streams based on mode
            if (streamingMode === 'direct') {
                // Add error handlers to all direct video elements
                console.log(`[Grid] Initializing ${cameras.length} direct streams...`);
                const startTime = performance.now();

                const videoElements = grid.querySelectorAll('video');
                videoElements.forEach((video, index) => {
                    const cameraName = (cameras[index] && cameras[index].name) || 'Unknown';

                    video.addEventListener('loadstart', () => {
                        console.log(`[Direct] ${cameraName}: Loading started`);
                    });

                    video.addEventListener('loadeddata', () => {
                        const loadTime = (performance.now() - startTime).toFixed(0);
                        console.log(`[Direct] ${cameraName}: Stream loaded (${loadTime}ms)`);
                    });

                    video.addEventListener('error', (e) => {
                        console.error(`[Direct] ${cameraName}: Stream error:`, {
                            error: e,
                            networkState: video.networkState,
                            readyState: video.readyState,
                            src: video.src
                        });
                    });

                    video.addEventListener('canplay', () => {
                        console.log(`[Direct] ${cameraName}: Ready to play`);
                    });
                });

            } else if (streamingMode === 'webrtc') {
                // Initialize ALL WebRTC players in parallel for maximum speed
                console.log(`[Grid] Starting ${cameras.length} WebRTC connections in parallel...`);
                const startTime = performance.now();

                // Start all connections simultaneously using Promise.all
                const connectionPromises = cameras.map(camera =>
                    initializeWebRTCPlayer(camera.name)
                );

                // Track when all connections complete
                Promise.all(connectionPromises).then(() => {
                    const totalTime = (performance.now() - startTime).toFixed(0);
                    console.log(`[Grid] All ${cameras.length} cameras connected in ${totalTime}ms`);
                }).catch(err => {
                    console.error('[Grid] Some cameras failed to connect:', err);
                });
            }
        }

        async function initializeWebRTCPlayer(cameraName) {
            const safeId = cameraName.replace(/[^a-zA-Z0-9-_]/g, '_');
            const videoElement = document.getElementById(`video-${safeId}`);

            if (!videoElement) {
                console.warn(`Video element not found for ${cameraName}`);
                return Promise.resolve();
            }

            // Create WebRTC player
            const player = new WebRTCPlayer(cameraName, videoElement);
            webrtcPlayers[cameraName] = player;

            // Return promise that resolves when video loads or rejects on error
            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    console.warn(`WebRTC connection timeout for ${cameraName}`);
                    resolve(); // Don't reject - just resolve to not block other cameras
                }, 10000); // 10 second timeout

                videoElement.addEventListener('loadeddata', () => {
                    clearTimeout(timeout);
                    console.log(`âœ“ WebRTC connected: ${cameraName}`);

                    // Hide loading indicator
                    const loadingIndicator = document.getElementById(`loading-${safeId}`);
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }

                    resolve();
                }, { once: true });

                videoElement.addEventListener('error', (err) => {
                    clearTimeout(timeout);
                    console.error(`âœ— WebRTC failed: ${cameraName}`, err);
                    resolve(); // Don't reject - just resolve to not block other cameras
                }, { once: true });

                // Start connection
                player.start().catch(err => {
                    clearTimeout(timeout);
                    console.error(`Failed to start WebRTC for ${cameraName}:`, err);
                    resolve(); // Don't reject - just resolve to not block other cameras
                });
            });
        }

        function createCameraCard(camera) {
            const card = document.createElement('div');
            card.className = 'camera-card';
            card.setAttribute('data-camera', camera.name);

            const safeId = camera.name.replace(/[^a-zA-Z0-9-_]/g, '_');

            // Choose video element based on streaming mode
            let videoHtml;
            if (streamingMode === 'direct') {
                // ULTRA-FAST: Direct RTSP proxy with native HTML5 video
                videoHtml = `<video autoplay playsinline muted style="width: 100%; height: 100%; object-fit: contain;"
                    src="/api/cameras/${encodeURIComponent(camera.name)}/stream/direct"></video>`;
            } else if (streamingMode === 'webrtc') {
                videoHtml = `<div style="position: relative; width: 100%; height: 100%;">
                    <video id="video-${safeId}" autoplay playsinline muted style="width: 100%; height: 100%; object-fit: contain;"></video>
                    <div id="loading-${safeId}" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #4a9eff; font-size: 0.9em; text-align: center;">
                        <div style="width: 30px; height: 30px; border: 3px solid rgba(74,158,255,0.3); border-top-color: #4a9eff; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 10px;"></div>
                        Connecting...
                    </div>
                </div>`;
            } else {
                // MJPEG fallback
                videoHtml = `<img src="${buildStreamUrl(camera.name)}" alt="${escapeHtml(camera.name)}" loading="lazy">`;
            }

            card.innerHTML = `
                <div class="camera-header">
                    <div class="camera-name-display" onclick="enableRename('${safeId}')" id="name-${safeId}">
                        ${escapeHtml(camera.name)}
                    </div>
                    <input type="text"
                           class="camera-name-input hidden"
                           id="input-${safeId}"
                           value="${escapeHtml(camera.name)}"
                           data-original-name="${escapeHtml(camera.name)}"
                           onkeydown="handleRenameKey(event, '${safeId}')">
                    <div class="rename-actions" id="actions-${safeId}">
                        <button class="rename-btn" type="button" onclick="console.log('Save clicked for ${safeId}'); saveRename('${safeId}')">âœ“ Save</button>
                        <button class="rename-btn cancel" type="button" onclick="console.log('Cancel clicked for ${safeId}'); cancelRename('${safeId}')">âœ• Cancel</button>
                    </div>
                    <button class="reconnect-btn" id="reconnect-${safeId}" onclick="reconnectCamera('${escapeHtml(camera.name)}')" title="Force reconnect camera">
                        â†»
                    </button>
                    <span class="status-recording" id="status-${safeId}">
                        <span class="rec-dot"></span>
                        REC
                    </span>
                </div>
                <div class="camera-video" onclick="goFullscreen('${escapeHtml(camera.name)}')">
                    ${videoHtml}
                    <div class="motion-indicator">MOTION</div>
                </div>
                <div class="camera-info">
                    <span>${streamingMode === 'direct' ? 'âš¡ DIRECT (Ultra-Fast)' : streamingMode === 'webrtc' ? 'ðŸš€ WebRTC' : 'ðŸ“¡ MJPEG'} | ${camera.device_info && camera.device_info.Manufacturer ?
                        `${camera.device_info.Manufacturer} ${camera.device_info.Model}` :
                        'Click name to rename â€¢ Click video for fullscreen'}</span>
                </div>
            `;

            return card;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function enableRename(safeId) {
            console.log('enableRename called for:', safeId);
            const display = document.getElementById(`name-${safeId}`);
            const input = document.getElementById(`input-${safeId}`);
            const actions = document.getElementById(`actions-${safeId}`);
            const status = document.getElementById(`status-${safeId}`);

            console.log('Elements found:', { display, input, actions, status });

            display.classList.add('hidden');
            status.classList.add('hidden');
            input.classList.remove('hidden');
            actions.classList.add('active');
            input.focus();
            input.select();

            console.log('Rename mode enabled, buttons should be visible');
        }

        function handleRenameKey(event, safeId) {
            if (event.key === 'Enter') {
                event.preventDefault();
                saveRename(safeId);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                cancelRename(safeId);
            }
        }

        async function saveRename(safeId) {
            const input = document.getElementById(`input-${safeId}`);
            const oldName = input.getAttribute('data-original-name');
            const newName = input.value.trim();

            console.log('saveRename called:', { safeId, oldName, newName });

            if (!newName) {
                alert('Camera name cannot be empty');
                return;
            }

            if (newName === oldName) {
                console.log('Name unchanged, canceling');
                cancelRename(safeId);
                return;
            }

            // Optimistically update UI immediately
            const display = document.getElementById(`name-${safeId}`);
            const actions = document.getElementById(`actions-${safeId}`);
            const status = document.getElementById(`status-${safeId}`);

            // Exit edit mode and show new name
            input.classList.add('hidden');
            actions.classList.remove('active');
            display.classList.remove('hidden');
            status.classList.remove('hidden');
            display.textContent = newName;

            // Update the data attribute to the new name for future edits
            input.setAttribute('data-original-name', newName);
            input.value = newName;

            try {
                const url = `/api/cameras/${encodeURIComponent(oldName)}/rename`;
                const payload = { old_name: oldName, new_name: newName };

                console.log('Sending rename request:', { url, payload });

                // Add timeout to fetch
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                    signal: controller.signal
                }).finally(() => clearTimeout(timeoutId));

                console.log('Response received:', response.status, response.statusText);

                if (response.ok) {
                    const result = await response.json();
                    console.log('Rename successful:', result);
                    // Update the cameras array to reflect the new name
                    const cameraIndex = cameras.findIndex(c => c.name === oldName);
                    if (cameraIndex !== -1) {
                        cameras[cameraIndex].name = newName;
                    }
                    // No need to reload the entire page - we already updated the UI optimistically
                } else {
                    let errorMessage = 'Unknown error';
                    try {
                        const error = await response.json();
                        errorMessage = error.detail || JSON.stringify(error);
                    } catch (e) {
                        errorMessage = response.statusText;
                    }
                    console.error('Rename failed:', response.status, errorMessage);
                    // Revert the UI change
                    display.textContent = oldName;
                    input.setAttribute('data-original-name', oldName);
                    input.value = oldName;
                    alert('Failed to rename camera: ' + errorMessage);
                }
            } catch (error) {
                console.error('Error renaming:', error);
                // Revert the UI change
                display.textContent = oldName;
                input.setAttribute('data-original-name', oldName);
                input.value = oldName;

                if (error.name === 'AbortError') {
                    alert('Request timed out. Is the server running?');
                } else {
                    alert('Error renaming camera: ' + error.message);
                }
            }
        }

        function cancelRename(safeId) {
            const display = document.getElementById(`name-${safeId}`);
            const input = document.getElementById(`input-${safeId}`);
            const actions = document.getElementById(`actions-${safeId}`);
            const status = document.getElementById(`status-${safeId}`);
            const oldName = input.getAttribute('data-original-name');

            input.classList.add('hidden');
            actions.classList.remove('active');
            display.classList.remove('hidden');
            status.classList.remove('hidden');
            input.value = oldName;
        }

        function goFullscreen(cameraName) {
            // Open in new tab immediately for instant response
            window.open(`/fullscreen/${encodeURIComponent(cameraName)}`, '_blank');
        }

        async function reconnectCamera(cameraName) {
            try {
                const response = await fetch(`/api/cameras/${encodeURIComponent(cameraName)}/reconnect`, {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.success) {
                    console.log(`Reconnecting ${cameraName}...`);
                    // Optionally show a temporary notification
                    const safeId = cameraName.replace(/[^a-z0-9]/gi, '_');
                    const statusElem = document.getElementById(`status-${safeId}`);
                    if (statusElem) {
                        const originalHTML = statusElem.innerHTML;
                        statusElem.innerHTML = '<span class="rec-dot"></span> RECONNECTING...';
                        setTimeout(() => {
                            statusElem.innerHTML = originalHTML;
                        }, 3000);
                    }
                } else {
                    console.error(`Failed to reconnect ${cameraName}:`, result.error);
                    alert(`Failed to reconnect: ${result.error}`);
                }
            } catch (error) {
                console.error(`Error reconnecting ${cameraName}:`, error);
                alert(`Error reconnecting camera: ${error.message}`);
            }
        }

        async function fetchSystemStats() {
            try {
                const response = await fetch('/api/system/stats');
                const stats = await response.json();

                // Update CPU usage
                const cpuElem = document.getElementById('cpu-usage');
                cpuElem.textContent = `${stats.cpu.percent}%`;
                cpuElem.style.color = stats.cpu.percent > 80 ? '#ff4a4a' : stats.cpu.percent > 60 ? '#ffa500' : '#4aff4a';

                // Update Memory usage
                const memElem = document.getElementById('memory-usage');
                memElem.textContent = `${stats.memory.percent}%`;
                memElem.style.color = stats.memory.percent > 80 ? '#ff4a4a' : stats.memory.percent > 60 ? '#ffa500' : '#4aff4a';

                // Update Disk usage
                const diskElem = document.getElementById('disk-usage');
                diskElem.textContent = `${stats.disk.percent}%`;
                diskElem.style.color = stats.disk.percent > 80 ? '#ff4a4a' : stats.disk.percent > 60 ? '#ffa500' : '#4aff4a';
            } catch (error) {
                console.error('Error fetching system stats:', error);
            }
        }

        // Initialize
        fetchCameras();
        fetchSystemStats();
        // Periodic refresh every 5 seconds
        setInterval(fetchCameras, 5000);
        setInterval(fetchSystemStats, 2000); // Update stats every 2 seconds

        // WebSocket for motion events
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${protocol}//${window.location.host}/ws/events`);

        ws.onmessage = (event) => {
            const events = JSON.parse(event.data);
            events.forEach(e => {
                if (e.type === 'motion') {
                    const card = document.querySelector(`[data-camera="${e.camera}"]`);
                    if (card) {
                        const indicator = card.querySelector('.motion-indicator');
                        indicator.classList.add('active');
                        setTimeout(() => indicator.classList.remove('active'), 3000);
                    }
                }
            });
        };
    </script>
</body>
</html>
